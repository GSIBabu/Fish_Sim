<!DOCTYPE html>
<html lang="ka">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>თევზის მამოძრავებელი სისტემის სიმულაცია - Xპერიმენტ Lab</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Favicon -->
    <link rel="shortcut icon" type="image/x-icon" href="favicon.ico">
    <style>
        body { margin: 0; overflow: hidden; font-family: sans-serif; background-color: #111827; }
        canvas { display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 0; }
        /* Style for view containers - adjust border/bg as needed for debugging */
        .view-container {
            /* background-color: rgba(255, 255, 255, 0.05); */
            /* border: 1px dashed gray; */
            position: relative; /* Needed for label positioning */
            overflow: hidden; /* Clip content */
            pointer-events: none; /* Allow canvas below to receive events */
        }
        .view-label {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.6);
            color: white;
            padding: 4px 8px;
            font-size: 16px;
            border-radius: 4px;
            pointer-events: none; /* Don't interfere with container */
            z-index: 10;
        }
        /* Basic slider look */
        input[type="range"] { accent-color: #3b82f6; }
        .value-indicator {
            font-size: 20px;
            font-weight: 500;
            color: #4b5563;
            background-color: #e5e7eb;
            padding: 2px 6px;
            border-radius: 4px;
            min-width: 30px; /* Ensure consistent width */
            text-align: right;
        }
         /* Loading indicator */
        #loadingContainer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; justify-content: center; align-items: center;
            background-color: rgba(0, 0, 0, 0.7); z-index: 50;
        }
        .spinner {
            border: 4px solid rgba(255,255,255,0.2); border-radius: 50%;
            border-top: 4px solid #3498db; width: 40px; height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* Styles copied from original index.html for toggle and metrics */
        /* Custom styling for toggle switch */
        .toggle-checkbox:checked {
            right: 0;
            border-color: #3b82f6;
        }
        .toggle-checkbox:checked + .toggle-label {
            background-color: #3b82f6;
        }
         /* Metrics display - fixed within view */
        .metrics-display {
            position: absolute;
            top: 10px; /* Adjust position as needed */
            right: 10px; /* Adjust position as needed */
            z-index: 30;
            display: flex;
            flex-direction: column;
            gap: 8px;
            pointer-events: none; /* Allow clicks to pass through */
        }
        .metric-badge {
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 6px 12px;
            border-radius: 8px;
            backdrop-filter: blur(4px);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            display: flex;
            justify-content: space-between;
            align-items: center;
            min-width: 140px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .metric-badge-value {
            font-weight: 600;
            font-size: 20px;
            margin-left: 8px;
        }
        .metric-badge-label {
            opacity: 0.8;
            font-size: 16px;
        }
         /* Custom backgrounds for specific badges (optional) */
        #frictionBadge {
             background: linear-gradient(135deg, rgba(239, 68, 68, 0.7) 0%, rgba(217, 119, 6, 0.7) 100%); /* Red-Orange Gradient */
        }
        #speedBadge {
             background: linear-gradient(135deg, rgba(59, 130, 246, 0.7) 0%, rgba(14, 165, 233, 0.7) 100%); /* Blue-Cyan Gradient */
        }

    </style>
</head>
<body class="flex flex-col lg:flex-row h-screen text-gray-600">

    <!-- Wrapper for Sim Area and Metrics (for desktop positioning context) -->
    <div class="flex flex-col flex-grow lg:relative h-1/2 lg:h-auto"> <!-- Changed from h-3/5 -->

        <!-- Main Simulation Area -->
        <div id="simulation-area" class="flex-grow relative w-full"> <!-- flex-grow within wrapper -->
            <!-- Canvas sits underneath the view divs -->
            <canvas id="mainCanvas"></canvas>

            <!-- Responsive Grid Layout for Views -->
            <!-- Mobile: 2 cols (Top full height left, Side/Front stacked right) -->
            <!-- Desktop: 2 cols (Top full width top, Side/Front bottom) -->
            <div class="absolute top-0 left-0 w-full h-full grid grid-cols-2 grid-rows-2 gap-1 lg:gap-2 p-1 lg:p-2 z-10 pointer-events-none"> <!-- Base is 2x2 now -->
                <div id="view-top" class="view-container col-span-1 row-span-2 lg:col-span-2 lg:row-span-1"> <!-- Mobile: Left Col | Desktop: Top Row -->
                    <div class="view-label bottom-2 left-2 lg:bottom-auto lg:top-2">ზედა</div>
                </div>
                <div id="view-side" class="view-container col-span-1 row-span-1"> <!-- Mobile: Top Right | Desktop: Bottom Left -->
                    <div class="view-label bottom-2 left-2 lg:bottom-auto lg:top-2">გვერდითი</div>
                </div>
                <div id="view-front" class="view-container col-span-1 row-span-1"> <!-- Mobile: Bottom Right | Desktop: Bottom Right -->
                    <div class="view-label bottom-2 left-2 lg:bottom-auto lg:top-2">წინა</div>
                </div>
            </div>

            <!-- Loading Indicator -->
            <div id="loadingContainer">
                 <div class="spinner"></div>
            </div>
        </div>

        <!-- Metrics Display - Positioned between sim area and controls on mobile -->
        <!-- On Desktop, absolutely positioned relative to the new wrapper -->
        <div class="metrics-display w-full flex flex-row justify-center items-center gap-4 p-2 bg-gray-900 lg:absolute lg:top-10 lg:right-10 lg:w-auto lg:flex-col lg:bg-transparent lg:p-0 lg:pointer-events-none flex-shrink-0"> <!-- Added flex-shrink-0 -->
            <div id="frictionBadge" class="metric-badge">
                <span class="metric-badge-label">ჯამური წინაღობა:</span>
                <span id="frictionDisplayFixed" class="metric-badge-value">0.00</span>
            </div>
            <div id="speedBadge" class="metric-badge">
                <span class="metric-badge-label">სიჩქარე:</span>
                <span id="speedDisplayFixed" class="metric-badge-value">0.00</span>
            </div>
        </div>

    </div> <!-- End Wrapper -->

    <!-- Control Panel -->
    <!-- Stacks below wrapper on mobile, fixed width side panel on large screens -->
    <!-- Mobile: Fixed 2/5 height, no scroll -->
    <div class="w-full lg:w-64 bg-white p-2 lg:p-4 shadow-lg border-t lg:border-t-0 lg:border-l border-gray-300 flex flex-col gap-1 lg:gap-4 overflow-hidden lg:overflow-y-auto h-1/2 lg:h-screen flex-shrink-0"> <!-- Changed from h-2/5 -->
        <h2 class="text-2xl font-semibold text-black border-b border-gray-300 pb-0.5 lg:pb-2">მართვის პანელი</h2> <!-- Changed from text-xl -->

        <div>
            <h3 class="text-2xl font-semibold text-gray-800 text-center">ფორმა და ზომა</h3> <!-- Changed from text-xl -->
            <!-- Mobile: 2-column grid | Desktop: 1-column flex -->
            <div class="grid grid-cols-2 gap-x-3 lg:gap-x-4 gap-y-0.5 lg:flex lg:flex-col lg:gap-2"> <!-- Removed text-sm base -->
                <!-- Original Layout (Label above Slider+Value) - Items will flow into grid -->
                <div>
                    <label for="lengthSlider" class="block text-gray-700 font-medium text-xl">სიგრძე</label> <!-- Changed from text-lg -->
                    <div class="flex items-center gap-1 lg:gap-2"> <!-- Mobile: gap-1 -->
                        <input type="range" id="lengthSlider" min="1" max="5" value="3" step="0.1" class="flex-grow h-8 lg:h-auto"> <!-- Increased mobile height from h-6 -->
                        <span id="lengthValue" class="value-indicator">3.0</span>
                    </div>
                </div>
                 <div>
                    <label for="widthSlider" class="block text-gray-700 font-medium text-xl">სიგანე</label> <!-- Changed from text-lg -->
                    <div class="flex items-center gap-1 lg:gap-2"> <!-- Mobile: gap-1 -->
                        <input type="range" id="widthSlider" min="0.2" max="1.5" value="0.5" step="0.05" class="flex-grow h-8 lg:h-auto"> <!-- Increased mobile height from h-6 -->
                        <span id="widthValue" class="value-indicator">0.50</span>
                    </div>
                </div>
                 <div>
                    <label for="heightSlider" class="block text-gray-700 font-medium text-xl">სიმაღლე</label> <!-- Changed from text-lg -->
                    <div class="flex items-center gap-1 lg:gap-2"> <!-- Mobile: gap-1 -->
                        <input type="range" id="heightSlider" min="0.2" max="1.5" value="0.4" step="0.05" class="flex-grow h-8 lg:h-auto"> <!-- Increased mobile height from h-6 -->
                        <span id="heightValue" class="value-indicator">0.40</span>
                    </div>
                </div>
                 <div>
                    <label for="pointinessSlider" class="block text-gray-700 font-medium text-xl">წვეტიანობა</label> <!-- Changed from text-lg -->
                    <div class="flex items-center gap-1 lg:gap-2"> <!-- Mobile: gap-1 -->
                        <input type="range" id="pointinessSlider" min="0.1" max="1" value="0.5" step="0.05" class="flex-grow h-8 lg:h-auto"> <!-- Increased mobile height from h-6 -->
                        <span id="pointinessValue" class="value-indicator">0.50</span>
                    </div>
                </div>
                 <div>
                    <label for="roundnessSlider" class="block text-gray-700 font-medium text-xl">სიმრგვალე</label> <!-- Changed from text-lg -->
                    <div class="flex items-center gap-1 lg:gap-2"> <!-- Mobile: gap-1 -->
                        <input type="range" id="roundnessSlider" min="0.1" max="1" value="0.6" step="0.05" class="flex-grow h-8 lg:h-auto"> <!-- Increased mobile height from h-6 -->
                        <span id="roundnessValue" class="value-indicator">0.60</span>
                    </div>
                </div>
                 <div>
                    <label for="tailFinSizeSlider" class="block text-gray-700 font-medium text-xl">კუდის ფარფლის ზომა</label> <!-- Changed from text-lg -->
                    <div class="flex items-center gap-1 lg:gap-2"> <!-- Mobile: gap-1 -->
                        <input type="range" id="tailFinSizeSlider" min="0.1" max="1.5" value="0.5" step="0.05" class="flex-grow h-8 lg:h-auto"> <!-- Increased mobile height from h-6 -->
                        <span id="tailFinSizeValue" class="value-indicator">0.50</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Appearance Section -->
        <div class="border-t border-gray-300 pt-1 lg:pt-3">
            <h3 class="text-2xl font-semibold text-gray-800 text-center">ანატომიური თვისებები</h3> <!-- Changed from text-xl -->
            <!-- Mobile: 2-column grid | Desktop: 1-column flex -->
            <div class="grid grid-cols-2 gap-x-3 lg:gap-x-4 gap-y-0 lg:flex lg:flex-col lg:gap-1.5">
                <div class="flex items-center justify-between scale-90 lg:scale-100 origin-left">
                    <label for="mucusToggle" class="block text-gray-700 font-medium mr-1 text-xl">ლორწოს გამოყოფა</label> <!-- Changed from text-lg -->
                    <div class="relative inline-block w-12 mr-2 align-middle select-none transition duration-200 ease-in flex-shrink-0"> <!-- Increased width from w-10 -->
                        <input type="checkbox" name="mucusToggle" id="mucusToggle" class="toggle-checkbox absolute block w-6 h-6 rounded-full bg-white border-4 appearance-none cursor-pointer"/> <!-- Increased size from w-5 h-5 -->
                        <label for="mucusToggle" class="toggle-label block overflow-hidden h-6 rounded-full bg-gray-300 cursor-pointer"></label> <!-- Increased height from h-5 -->
                    </div>
                </div>
                <div class="flex items-center justify-between scale-90 lg:scale-100 origin-left">
                    <label for="pectoralFinToggle" class="block text-gray-700 font-medium mr-1 text-xl">მკერდის ფარფლები</label> <!-- Changed from text-lg -->
                    <div class="relative inline-block w-12 mr-2 align-middle select-none transition duration-200 ease-in flex-shrink-0"> <!-- Increased width from w-10 -->
                        <input type="checkbox" name="pectoralFinToggle" id="pectoralFinToggle" class="toggle-checkbox absolute block w-6 h-6 rounded-full bg-white border-4 appearance-none cursor-pointer" checked/> <!-- Increased size from w-5 h-5 -->
                        <label for="pectoralFinToggle" class="toggle-label block overflow-hidden h-6 rounded-full bg-gray-300 cursor-pointer"></label> <!-- Increased height from h-5 -->
                    </div>
                </div>
                <div class="flex items-center justify-between scale-90 lg:scale-100 origin-left">
                    <label for="pelvicFinToggle" class="block text-gray-700 font-medium mr-1 text-xl">მუცლის ფარფლები</label> <!-- Changed from text-lg -->
                    <div class="relative inline-block w-12 mr-2 align-middle select-none transition duration-200 ease-in flex-shrink-0"> <!-- Increased width from w-10 -->
                        <input type="checkbox" name="pelvicFinToggle" id="pelvicFinToggle" class="toggle-checkbox absolute block w-6 h-6 rounded-full bg-white border-4 appearance-none cursor-pointer" checked/> <!-- Increased size from w-5 h-5 -->
                        <label for="pelvicFinToggle" class="toggle-label block overflow-hidden h-6 rounded-full bg-gray-300 cursor-pointer"></label> <!-- Increased height from h-5 -->
                    </div>
                </div>
                <div class="flex items-center justify-between scale-90 lg:scale-100 origin-left">
                    <label for="tailFinToggle" class="block text-gray-700 font-medium mr-1 text-xl">კუდის ფარფლი</label> <!-- Changed from text-lg -->
                    <div class="relative inline-block w-12 mr-2 align-middle select-none transition duration-200 ease-in flex-shrink-0"> <!-- Increased width from w-10 -->
                        <input type="checkbox" name="tailFinToggle" id="tailFinToggle" class="toggle-checkbox absolute block w-6 h-6 rounded-full bg-white border-4 appearance-none cursor-pointer" checked/> <!-- Increased size from w-5 h-5 -->
                        <label for="tailFinToggle" class="toggle-label block overflow-hidden h-6 rounded-full bg-gray-300 cursor-pointer"></label> <!-- Increased height from h-5 -->
                    </div>
                </div>
            </div>
        </div>


        <div class="text-sm text-gray-600 mt-auto pt-0.5 lg:pt-1 border-t border-gray-300 text-center"> <!-- Changed from text-xs -->
             Xპერიმენტ Lab © 2025 შპს "საქართველოს სამეცნიერო ინდუსტრიები"
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        let scene, renderer, cameras = {};
        let fishMesh, fishMaterial; // Back to single mesh
        let controls = {};
        let animationFrameId;
        let isMucusActive = false; // Physics state
        let arePectoralFinsVisible = true; // State for pectoral fins
        let arePelvicFinsVisible = true; // State for pelvic fins
        let isTailFinVisible = true; // State for tail fin

        // --- Stabilization Animation parameters --- (Updated for Pelvic Fins)
        let animationTime = 0;
        const clock = new THREE.Clock(); // Use THREE.Clock for smoother animation timing
        // Roll (Z-axis rotation) parameters
        const rollFrequency = 2.5;        // Radians per second
        const baseRollAmplitude = Math.PI / 16; // Unstabilized max roll (approx 11 deg)
        const pectoralStabilizedRollAmplitude = Math.PI / 64; // Pectoral max roll (approx 3 deg)
        const pelvicStabilizedRollAmplitude = Math.PI / 180; // Pelvic max roll (approx 1 deg) - Strongest stabilization
        // Pitch (X-axis rotation) parameters
        const pitchFrequency = 1.8;       // Radians per second (slightly different from roll)
        const basePitchAmplitude = Math.PI / 32; // Unstabilized max pitch (approx 5.5 deg)
        const pectoralStabilizedPitchAmplitude = Math.PI / 128;// Pectoral max pitch (approx 1.4 deg)
        const pelvicStabilizedPitchAmplitude = Math.PI / 360; // Pelvic max pitch (approx 0.5 deg) - Strongest stabilization
        // ------------------------------------------

        // --- Particle Speed Scaling ---
        const particleSpeedFactor = 1.0; // Adjust this to control particle speed relative to fish speed
        // -----------------------------

        // --- Tail Animation parameters ---
        const tailFrequency = 5;        // How fast the tail oscillates
        const tailRotationAmplitude = Math.PI / 6; // Max rotation angle (approx 30 degrees)
        // Variables for vertex deformation animation
        let originalAnimatedVertices = null; // Stores original [x,y,z, x,y,z, ...] for animated vertices
        let animatedVertexIndices = [];   // Stores the indices (0, 1, 2, ...) within the geometry's position attribute
        let firstAnimatedVertexIndex = -1; // Starting index in the geometry's buffer
        const numBodyAnimSegments = 2;     // How many body segments to include in the animation blend
        // ---------------------------------

        // Initialize metrics object with more detail
        let metrics = {
            formDrag: 0,
            frictionDrag: 0,
            totalDrag: 0,
            thrustPotential: 0,
            speed: 0
        };
        // Particle system variables
        let particles, particleGeometry, particleMaterial;
        const particleCount = 1500; // Adjusted count
        const particleVelocities = [];
        const particleSpawnBox = new THREE.Box3(
            new THREE.Vector3(-10, -6, -15),
            new THREE.Vector3(10, 6, -12)
        );
        const simulationBounds = new THREE.Box3(
            new THREE.Vector3(-12, -7, -20),
            new THREE.Vector3(12, 7, 15)
        );

        // DOM Elements
        const canvas = document.getElementById('mainCanvas');
        const simulationArea = document.getElementById('simulation-area');
        const loadingContainer = document.getElementById('loadingContainer');
        const viewContainers = {
            top: document.getElementById('view-top'),
            side: document.getElementById('view-side'),
            front: document.getElementById('view-front'),
        };
        const sliders = {
            length: document.getElementById('lengthSlider'),
            width: document.getElementById('widthSlider'),
            height: document.getElementById('heightSlider'),
            pointiness: document.getElementById('pointinessSlider'),
            roundness: document.getElementById('roundnessSlider'),
            tailFinSize: document.getElementById('tailFinSizeSlider'),
        };
        const valueSpans = {
            length: document.getElementById('lengthValue'),
            width: document.getElementById('widthValue'),
            height: document.getElementById('heightValue'),
            pointiness: document.getElementById('pointinessValue'),
            roundness: document.getElementById('roundnessValue'),
            tailFinSize: document.getElementById('tailFinSizeValue'),
        };
        const mucusToggle = document.getElementById('mucusToggle');
        const pectoralFinToggle = document.getElementById('pectoralFinToggle'); // Reference for the new toggle
        const pelvicFinToggle = document.getElementById('pelvicFinToggle');   // Reference for pelvic fin toggle
        const tailFinToggle = document.getElementById('tailFinToggle');     // Reference for tail fin toggle
        const frictionDisplayFixed = document.getElementById('frictionDisplayFixed');
        const speedDisplayFixed = document.getElementById('speedDisplayFixed');


        // --- Initialization ---
        function init() {
            try {
                // Scene
                scene = new THREE.Scene();
                // scene.background set per-viewport in render loop

                // Renderer (Single)
                renderer = new THREE.WebGLRenderer({
                    canvas: canvas,
                    antialias: true,
                    alpha: true // Canvas is transparent, backgrounds are set per viewport
                });
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.setSize(simulationArea.clientWidth, simulationArea.clientHeight);
                renderer.setScissorTest(true); // IMPORTANT for multiple viewports
                renderer.setClearColor(0x000000, 0); // Make overall canvas clear

                // Lighting
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
                scene.add(ambientLight);
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(5, 10, 7);
                scene.add(directionalLight);

                // Cameras (Orthographic) - Initialize with placeholder size, will be updated in render()
                const initialPlaceholderSize = 1; // Temporary size for init
                cameras.top = new THREE.OrthographicCamera(-initialPlaceholderSize / 2, initialPlaceholderSize / 2, initialPlaceholderSize / 2, -initialPlaceholderSize / 2, 0.1, 100);
                cameras.top.position.set(0, 10, 0);
                cameras.top.lookAt(0, 0, 0);
                scene.add(cameras.top);

                cameras.side = new THREE.OrthographicCamera(-initialPlaceholderSize / 2, initialPlaceholderSize / 2, initialPlaceholderSize / 2, -initialPlaceholderSize / 2, 0.1, 100);
                cameras.side.position.set(10, 0, 0);
                cameras.side.lookAt(0, 0, 0);
                scene.add(cameras.side);

                cameras.front = new THREE.OrthographicCamera(-initialPlaceholderSize / 2, initialPlaceholderSize / 2, initialPlaceholderSize / 2, -initialPlaceholderSize / 2, 0.1, 100);
                cameras.front.position.set(0, 0, 10); // Looking along negative Z
                cameras.front.lookAt(0, 0, 0);
                scene.add(cameras.front);

                // Fish Material
                 fishMaterial = new THREE.MeshStandardMaterial({
                    color: 0xe53e3e, // Red
                    metalness: 0.2,
                    roughness: 0.7,
                    side: THREE.DoubleSide,
                });

                // Fish Object
                // updateShape(); // Called later

                // Add Grid Helper for orientation (Floor)
                const gridHelperXZ = new THREE.GridHelper(10, 10, 0x4a5568, 0x2d3748);
                // scene.add(gridHelperXZ); // <-- Commented out to disable grid

                // Create Particles
                createParticles();

                // Event Listeners
                for (const key in sliders) {
                    if (sliders[key]) {
                        controls[key] = parseFloat(sliders[key].value);
                        sliders[key].addEventListener('input', handleSliderChange);
                    }
                }
                 if (mucusToggle) {
                     mucusToggle.addEventListener('change', updatePhysicsParameters);
                 }
                 // Add event listener for the new pectoral fin toggle
                 if (pectoralFinToggle) {
                     arePectoralFinsVisible = pectoralFinToggle.checked; // Initialize based on default state
                     pectoralFinToggle.addEventListener('change', () => {
                        arePectoralFinsVisible = pectoralFinToggle.checked;
                        updateShape(); // Update shape when toggled
                     });
                 }
                 // Add event listener for the pelvic fin toggle
                 if (pelvicFinToggle) {
                     arePelvicFinsVisible = pelvicFinToggle.checked; // Initialize based on default state
                     pelvicFinToggle.addEventListener('change', () => {
                         arePelvicFinsVisible = pelvicFinToggle.checked;
                         updateShape(); // Update shape when toggled
                     });
                 }
                 // Add event listener for the tail fin toggle
                 if (tailFinToggle) {
                     isTailFinVisible = tailFinToggle.checked; // Initialize based on default state
                     tailFinToggle.addEventListener('change', () => {
                        isTailFinVisible = tailFinToggle.checked;
                         updateShape(); // Update shape when toggled
                     });
                 }
                window.addEventListener('resize', onWindowResize);

                // Initial Update
                updateControlValues();
                updatePhysicsParameters(); 
                updateShape(); // Call this AFTER controls are initialized & particles created
                onWindowResize(); 

                // Hide loading
                loadingContainer.style.display = 'none';

            } catch (error) {
                console.error("Initialization failed:", error);
                loadingContainer.innerHTML = `<div class="text-red-500 p-4 bg-red-900 bg-opacity-50 rounded">Error: ${error.message}</div>`;
            }
        }

        // --- Create Particles ---
        function createParticles() {
            const positions = new Float32Array(particleCount * 3);

            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                // Random position within the spawn box
                positions[i3] = THREE.MathUtils.randFloat(particleSpawnBox.min.x, particleSpawnBox.max.x);
                positions[i3 + 1] = THREE.MathUtils.randFloat(particleSpawnBox.min.y, particleSpawnBox.max.y);
                positions[i3 + 2] = THREE.MathUtils.randFloat(particleSpawnBox.min.z, particleSpawnBox.max.z);

                // Initialize velocity (mostly forward in Z)
                particleVelocities.push(new THREE.Vector3(
                    THREE.MathUtils.randFloat(-0.008, 0.008), // Slight sideways drift
                    THREE.MathUtils.randFloat(-0.008, 0.008), // Slight vertical drift
                    THREE.MathUtils.randFloat(0.06, 0.12)     // Forward speed
                ));
            }

            particleGeometry = new THREE.BufferGeometry();
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

            particleMaterial = new THREE.PointsMaterial({
                color: 0x87cefa, // Lighter Blue (LightSkyBlue)
                size: 0.8,       // Slightly larger size
                sizeAttenuation: true,
                transparent: true,
                opacity: 0.8     // Slightly transparent
            });

            particles = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particles);
        }

        // --- Create Fish Geometry (Modified for separate body/tail) ---
         function createFishGeometry(length, width, height, pointiness, roundness, tailFinSizeParam, showPectoralFins, showPelvicFins, showTailFin) {
            // --- Combined Geometry --- 
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            const indices = [];
            const segmentsLength = 20;
            const segmentsCircumference = 16;
            const tailFinSize = tailFinSizeParam; // Use the parameter directly

            // Create body vertices (as before)
            for (let i = 0; i <= segmentsLength; i++) {
                const t = i / segmentsLength;
                const z = (t - 0.5) * length;
                const radiusMultiplier = Math.sin(Math.PI * t);
                const taperAmount = Math.pow(1.0 - t, 4.0) * pointiness;
                const noseTaper = 1.0 - taperAmount;
                const bodyShape = 1.0 + Math.sin(t * Math.PI) * (roundness - 0.5) * 0.8;
                const segmentWidth = width * radiusMultiplier * noseTaper * bodyShape;
                const segmentHeight = height * radiusMultiplier * noseTaper * bodyShape;

                for (let j = 0; j < segmentsCircumference; j++) {
                    const theta = (j / segmentsCircumference) * Math.PI * 2;
                    const x = segmentWidth * Math.cos(theta) * 0.5;
                    let y = segmentHeight * Math.sin(theta) * 0.5;
                    if (y < 0) y *= 0.8;
                    vertices.push(x, y, z); // Add to main vertices array
                }
            }

            // Create body indices (as before)
            for (let i = 0; i < segmentsLength; i++) {
                for (let j = 0; j < segmentsCircumference; j++) {
                    const current = i * segmentsCircumference + j;
                    const next = i * segmentsCircumference + (j + 1) % segmentsCircumference;
                    const nextRow = (i + 1) * segmentsCircumference + j;
                    const nextRowNext = (i + 1) * segmentsCircumference + (j + 1) % segmentsCircumference;
                    indices.push(current, nextRow, next);
                    indices.push(next, nextRow, nextRowNext);
                }
            }

            // --- Fins remain part of the main geometry --- 
            // --- Pectoral Fins ---
            if (showPectoralFins) {
                const pectStartIndex = vertices.length / 3;
                const finZ = length * (0.5 - 0.66);
                const finY = -height * 0.1;
                const finWidth = width * 0.6;
                const finLength = length * 0.15;
                const finSlant = finWidth * 0.25;
                const pectThickness = 0.02;

                // Calculate body radius at attachment point (as before)
                const finT = (finZ / length) + 0.5;
                const finRadiusMultiplier = Math.sin(Math.PI * finT);
                const finTaperAmount = Math.pow(1.0 - finT, 4.0) * pointiness;
                const finNoseTaper = 1.0 - finTaperAmount;
                const finBodyShape = 1.0 + Math.sin(finT * Math.PI) * (roundness - 0.5) * 0.8;
                const finSegmentWidth = width * finRadiusMultiplier * finNoseTaper * finBodyShape;
                const actualBodyRadiusX = finSegmentWidth * 0.5;
                const finAttachX = actualBodyRadiusX * 0.95;

                const leftAttach = [-finAttachX, finY, finZ];
                const leftOuter = [-finAttachX - finWidth, finY - finSlant, finZ + finLength * 0.5];
                const leftRear = [-finAttachX, finY, finZ + finLength];
                const rightAttach = [finAttachX, finY, finZ];
                const rightOuter = [finAttachX + finWidth, finY - finSlant, finZ + finLength * 0.5];
                const rightRear = [finAttachX, finY, finZ + finLength];

                // Add pectoral vertices (as before)
                vertices.push(leftAttach[0], leftAttach[1] + pectThickness / 2, leftAttach[2]); // 0
                vertices.push(leftOuter[0], leftOuter[1] + pectThickness / 2, leftOuter[2]);   // 1
                vertices.push(leftRear[0], leftRear[1] + pectThickness / 2, leftRear[2]);     // 2
                vertices.push(leftAttach[0], leftAttach[1] - pectThickness / 2, leftAttach[2]); // 3
                vertices.push(leftOuter[0], leftOuter[1] - pectThickness / 2, leftOuter[2]);   // 4
                vertices.push(leftRear[0], leftRear[1] - pectThickness / 2, leftRear[2]);     // 5
                vertices.push(rightAttach[0], rightAttach[1] + pectThickness / 2, rightAttach[2]); // 6
                vertices.push(rightOuter[0], rightOuter[1] + pectThickness / 2, rightOuter[2]);   // 7
                vertices.push(rightRear[0], rightRear[1] + pectThickness / 2, rightRear[2]);     // 8
                vertices.push(rightAttach[0], rightAttach[1] - pectThickness / 2, rightAttach[2]); // 9
                vertices.push(rightOuter[0], rightOuter[1] - pectThickness / 2, rightOuter[2]);   // 10
                vertices.push(rightRear[0], rightRear[1] - pectThickness / 2, rightRear[2]);     // 11

                // Add pectoral indices (as before)
                const l = pectStartIndex;
                indices.push(l+0, l+1, l+2); indices.push(l+3, l+5, l+4); indices.push(l+0, l+3, l+1);
                indices.push(l+1, l+3, l+4); indices.push(l+1, l+4, l+2); indices.push(l+2, l+4, l+5);
                indices.push(l+2, l+5, l+0); indices.push(l+0, l+5, l+3);
                const r = pectStartIndex + 6;
                indices.push(r+0, r+2, r+1); indices.push(r+3, r+4, r+5); indices.push(r+0, r+1, r+3);
                indices.push(r+1, r+4, r+3); indices.push(r+1, r+2, r+4); indices.push(r+2, r+5, r+4);
                indices.push(r+2, r+0, r+5); indices.push(r+0, r+3, r+5);
            }

            // --- Pelvic Fins ---
            if (showPelvicFins) {
                const pelvicStartIndex = vertices.length / 3;
                const finZ = length * (0.5 - 0.60);
                const finWidth = width * 0.35;
                const finLength = length * 0.15;
                const finSlant = finWidth * 0.60;
                const finThickness = 0.015;

                // Calculate body radius at attachment (as before)
                const finT = (finZ / length) + 0.5;
                const finRadiusMultiplier = Math.sin(Math.PI * finT);
                const finTaperAmount = Math.pow(1.0 - finT, 4.0) * pointiness;
                const finNoseTaper = 1.0 - finTaperAmount;
                const finBodyShape = 1.0 + Math.sin(finT * Math.PI) * (roundness - 0.5) * 0.8;
                const finSegmentHeight = height * finRadiusMultiplier * finNoseTaper * finBodyShape * 0.8;
                const actualBodyRadiusY = finSegmentHeight * 0.5;
                const finAttachY = -actualBodyRadiusY * 0.95;

                const finAttachWidth = width * 0.15;
                const leftAttach = [-finAttachWidth, finAttachY, finZ];
                const leftOuter = [-finAttachWidth - finWidth, finAttachY - finSlant, finZ + finLength * 0.5];
                const leftRear = [-finAttachWidth, finAttachY, finZ + finLength];
                const rightAttach = [finAttachWidth, finAttachY, finZ];
                const rightOuter = [finAttachWidth + finWidth, finAttachY - finSlant, finZ + finLength * 0.5];
                const rightRear = [finAttachWidth, finAttachY, finZ + finLength];

                // Add pelvic vertices (as before)
                vertices.push(leftAttach[0], leftAttach[1] + finThickness / 2, leftAttach[2]); // 0
                vertices.push(leftOuter[0], leftOuter[1] + finThickness / 2, leftOuter[2]);   // 1
                vertices.push(leftRear[0], leftRear[1] + finThickness / 2, leftRear[2]);     // 2
                vertices.push(leftAttach[0], leftAttach[1] - finThickness / 2, leftAttach[2]); // 3
                vertices.push(leftOuter[0], leftOuter[1] - finThickness / 2, leftOuter[2]);   // 4
                vertices.push(leftRear[0], leftRear[1] - finThickness / 2, leftRear[2]);     // 5
                vertices.push(rightAttach[0], rightAttach[1] + finThickness / 2, rightAttach[2]); // 6
                vertices.push(rightOuter[0], rightOuter[1] + finThickness / 2, rightOuter[2]);   // 7
                vertices.push(rightRear[0], rightRear[1] + finThickness / 2, rightRear[2]);     // 8
                vertices.push(rightAttach[0], rightAttach[1] - finThickness / 2, rightAttach[2]); // 9
                vertices.push(rightOuter[0], rightOuter[1] - finThickness / 2, rightOuter[2]);   // 10
                vertices.push(rightRear[0], rightRear[1] - finThickness / 2, rightRear[2]);     // 11

                // Add pelvic indices (as before)
                const l_pelvic = pelvicStartIndex;
                indices.push(l_pelvic+0, l_pelvic+1, l_pelvic+2); indices.push(l_pelvic+3, l_pelvic+5, l_pelvic+4);
                indices.push(l_pelvic+0, l_pelvic+3, l_pelvic+1); indices.push(l_pelvic+1, l_pelvic+3, l_pelvic+4);
                indices.push(l_pelvic+1, l_pelvic+4, l_pelvic+2); indices.push(l_pelvic+2, l_pelvic+4, l_pelvic+5);
                indices.push(l_pelvic+2, l_pelvic+5, l_pelvic+0); indices.push(l_pelvic+0, l_pelvic+5, l_pelvic+3);
                const r_pelvic = pelvicStartIndex + 6;
                indices.push(r_pelvic+0, r_pelvic+2, r_pelvic+1); indices.push(r_pelvic+3, r_pelvic+4, r_pelvic+5);
                indices.push(r_pelvic+0, r_pelvic+1, r_pelvic+3); indices.push(r_pelvic+1, r_pelvic+4, r_pelvic+3);
                indices.push(r_pelvic+1, r_pelvic+2, r_pelvic+4); indices.push(r_pelvic+2, r_pelvic+5, r_pelvic+4);
                indices.push(r_pelvic+2, r_pelvic+0, r_pelvic+5); indices.push(r_pelvic+0, r_pelvic+3, r_pelvic+5);
            }

            // --- Tail Fin Vertices (Append conditionally) ---
            if (showTailFin) {
                const tailStartIndex = vertices.length / 3; // Index where tail vertices start
                const tailFinSize = tailFinSizeParam; // Use the parameter directly
                const tailBaseZ = length * 0.5; // Z position of the tail base
                const finThickness = 0.03;
                const tailPointBack = tailBaseZ - tailFinSize * 0.5; // Absolute Z of the tip

                // Calculate tail base width based on body shape at the end
                const connect_t = 1.0;
                const connect_radiusMultiplier = Math.sin(Math.PI * connect_t);
                const connect_taperAmount = Math.pow(1.0 - connect_t, 4.0) * pointiness;
                const connect_noseTaper = 1.0 - connect_taperAmount;
                const connect_bodyShape = 1.0 + Math.sin(connect_t * Math.PI) * (roundness - 0.5) * 0.8;
                const connect_segmentWidth = width * connect_radiusMultiplier * connect_noseTaper * connect_bodyShape;
                const tailBaseWidth = Math.max(0.02, connect_segmentWidth); 

                // Define tail vertices directly in world space coordinates
                // Front face
                vertices.push(-tailBaseWidth / 2, -tailFinSize / 2, tailBaseZ + finThickness / 2); // 0 (tailStartIndex)
                vertices.push(0, 0, tailPointBack + finThickness / 2);                             // 1: Tip 
                vertices.push(-tailBaseWidth / 2, tailFinSize / 2, tailBaseZ + finThickness / 2);  // 2
                vertices.push(tailBaseWidth / 2, -tailFinSize / 2, tailBaseZ + finThickness / 2);   // 3
                vertices.push(tailBaseWidth / 2, tailFinSize / 2, tailBaseZ + finThickness / 2);   // 4
                // Back face
                vertices.push(-tailBaseWidth / 2, -tailFinSize / 2, tailBaseZ - finThickness / 2); // 5
                vertices.push(0, 0, tailPointBack - finThickness / 2);                             // 6: Tip
                vertices.push(-tailBaseWidth / 2, tailFinSize / 2, tailBaseZ - finThickness / 2);  // 7
                vertices.push(tailBaseWidth / 2, -tailFinSize / 2, tailBaseZ - finThickness / 2);  // 8
                vertices.push(tailBaseWidth / 2, tailFinSize / 2, tailBaseZ - finThickness / 2);   // 9

                // Indices for the tail fin (relative to tailStartIndex)
                const ti = (idx) => tailStartIndex + idx; // Helper to add offset
                indices.push(ti(0), ti(1), ti(2)); indices.push(ti(0), ti(3), ti(1)); indices.push(ti(3), ti(4), ti(1)); indices.push(ti(4), ti(2), ti(1)); // Front
                indices.push(ti(5), ti(7), ti(6)); indices.push(ti(5), ti(6), ti(8)); indices.push(ti(8), ti(6), ti(9)); indices.push(ti(9), ti(6), ti(7)); // Back
                indices.push(ti(0), ti(5), ti(3)); indices.push(ti(3), ti(5), ti(8)); // Edge Bot L
                indices.push(ti(2), ti(7), ti(0)); indices.push(ti(0), ti(7), ti(5)); // Edge Top L
                indices.push(ti(3), ti(8), ti(4)); indices.push(ti(4), ti(8), ti(9)); // Edge Bot R
                indices.push(ti(4), ti(9), ti(2)); indices.push(ti(2), ti(9), ti(7)); // Edge Top R
                indices.push(ti(1), ti(2), ti(6)); indices.push(ti(6), ti(2), ti(7)); // Edge Tip TL
                indices.push(ti(1), ti(6), ti(0)); indices.push(ti(6), ti(5), ti(0)); // Edge Tip BL
                indices.push(ti(1), ti(4), ti(6)); indices.push(ti(6), ti(9), ti(4)); // Edge Tip TR
                indices.push(ti(1), ti(6), ti(3)); indices.push(ti(6), ti(8), ti(3)); // Edge Tip BR
            }

            // Finalize combined geometry
            geometry.setIndex(indices);
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.computeVertexNormals();

            return geometry; // Return single geometry
        }


        // --- Update Fish Shape (Using Single Mesh) ---
        function updateShape() {
            for (const key in sliders) {
                if (sliders[key]) {
                    controls[key] = parseFloat(sliders[key].value);
                }
            }

             try {
                // Create the single geometry, passing the tail visibility state
                const newGeometry = createFishGeometry(
                    controls.length, controls.width, controls.height,
                    controls.pointiness, controls.roundness, controls.tailFinSize,
                    arePectoralFinsVisible,
                    arePelvicFinsVisible,
                    isTailFinVisible // Pass the state
                );

                // --- Dispose of old geometry --- 
                if (fishMesh) {
                    fishMesh.geometry.dispose();
                }
                
                // --- Create/Update Mesh --- 
                if (!fishMaterial) { 
                    fishMaterial = new THREE.MeshStandardMaterial({
                        color: 0xe53e3e, metalness: 0.2, roughness: 0.7, side: THREE.DoubleSide
                    });
                }

                if (!fishMesh) {
                    fishMesh = new THREE.Mesh(newGeometry, fishMaterial);
                    scene.add(fishMesh);
                } else {
                    fishMesh.geometry = newGeometry;
                }

                // --- Store Original Vertices for Animation ---
                storeOriginalAnimatedVertices(); // Call helper function

                updateControlValues();
             } catch (error) {
                console.error("Error updating fish shape:", error);
             }
        }

        // --- Store Original Vertex Data for Animation ---
        function storeOriginalAnimatedVertices() {
            if (!fishMesh || !fishMesh.geometry || !fishMesh.geometry.attributes.position) {
                console.warn("Cannot store vertices: Fish mesh or geometry not ready.");
                originalAnimatedVertices = null;
                animatedVertexIndices = [];
                firstAnimatedVertexIndex = -1;
                return;
            }

            const positions = fishMesh.geometry.attributes.position.array;
            const numVerticesTotal = positions.length / 3;

            // Calculate the starting index of the vertices we want to animate
            // Body vertices count = (segmentsLength + 1) * segmentsCircumference
            // Fins are added after body
            // Tail vertices (10) are added last.
            const segmentsLength = 20; // Make sure these match createFishGeometry
            const segmentsCircumference = 16;
            const numBodyVertices = (segmentsLength + 1) * segmentsCircumference;
            // Pectoral fins add 12 vertices if visible
            const numPectoralVertices = arePectoralFinsVisible ? 12 : 0;
             // Pelvic fins add 12 vertices if visible
            const numPelvicVertices = arePelvicFinsVisible ? 12 : 0;
            const numTailVerticesExplicit = isTailFinVisible ? 10 : 0; // Only include if visible

            // Start index of the tail fin vertices
            const tailStartIndex = numBodyVertices + numPectoralVertices + numPelvicVertices;

            // Start index of the body segments we want to animate
            // We want the last `numBodyAnimSegments` segments + the final ring
            const firstBodyAnimSegment = segmentsLength - numBodyAnimSegments;
            firstAnimatedVertexIndex = firstBodyAnimSegment * segmentsCircumference;

            // Calculate total number of vertices to animate
            const numBodyAnimVertices = (numBodyAnimSegments + 1) * segmentsCircumference;
            const numTotalAnimatedVertices = numBodyAnimVertices + numTailVerticesExplicit;


            originalAnimatedVertices = new Float32Array(numTotalAnimatedVertices * 3);
            animatedVertexIndices = []; // Reset indices array

            let storedCount = 0;
            // Store last body segments
            for (let i = firstBodyAnimSegment; i <= segmentsLength; i++) {
                for (let j = 0; j < segmentsCircumference; j++) {
                    const vertexIndex = i * segmentsCircumference + j;
                    if (vertexIndex >= numBodyVertices) continue; // Should not happen, but safety check

                    const bufferIndex = vertexIndex * 3;
                    originalAnimatedVertices[storedCount * 3] = positions[bufferIndex];
                    originalAnimatedVertices[storedCount * 3 + 1] = positions[bufferIndex + 1];
                    originalAnimatedVertices[storedCount * 3 + 2] = positions[bufferIndex + 2];
                    animatedVertexIndices.push(vertexIndex); // Store the index in the main buffer
                    storedCount++;
                }
            }

             // Store tail vertices (only if they exist)
             if (isTailFinVisible) {
                 for (let i = 0; i < 10; i++) { // Loop through the 10 tail vertex indices
                     const vertexIndex = tailStartIndex + i;
                     if (vertexIndex >= numVerticesTotal) continue; // Safety check

                     const bufferIndex = vertexIndex * 3;
                     originalAnimatedVertices[storedCount * 3] = positions[bufferIndex];
                     originalAnimatedVertices[storedCount * 3 + 1] = positions[bufferIndex + 1];
                     originalAnimatedVertices[storedCount * 3 + 2] = positions[bufferIndex + 2];
                     animatedVertexIndices.push(vertexIndex); // Store the index in the main buffer
                     storedCount++;
                 }
             }

            // console.log(`Stored ${storedCount} animated vertices starting from index ${firstAnimatedVertexIndex}`);
            if (storedCount !== numTotalAnimatedVertices) {
                 console.warn(`Vertex storage mismatch: Expected ${numTotalAnimatedVertices}, Stored ${storedCount}`);
                 // Handle potential error - maybe reset animation state?
                 originalAnimatedVertices = null;
                 animatedVertexIndices = [];
                 firstAnimatedVertexIndex = -1;
             }
        }

        // --- Update UI Control Values ---
        function updateControlValues() {
            for (const key in valueSpans) {
                 if (valueSpans[key] && sliders[key]) {
                    valueSpans[key].textContent = parseFloat(sliders[key].value).toFixed(key === 'length' ? 1 : 2);
                 }
            }
        }

        // --- Handle Slider Changes ---
        function handleSliderChange(event) {
            updateShape();
            // Note: Metrics are updated in the render loop based on shape/physics state
        }

        // --- Update Physics Parameters (Mucus Toggle) ---
        function updatePhysicsParameters() {
            if (mucusToggle) {
                isMucusActive = mucusToggle.checked;
            }
             // Metrics will be recalculated in the render loop
        }


        // --- Resize Handler ---
        function onWindowResize() {
            const simAreaWidth = simulationArea.clientWidth;
            const simAreaHeight = simulationArea.clientHeight;
            renderer.setSize(simAreaWidth, simAreaHeight);
            // Camera adjustments are handled per-frame in render()
        }


        // --- Animation Loop ---
        function animate() {
            animationFrameId = requestAnimationFrame(animate);

            const deltaTime = clock.getDelta(); 
            animationTime += deltaTime; 

            updateParticlePositions();

            // Apply stabilization rotation to the whole mesh
            if (fishMesh) {
                // --- Stabilization (Roll/Pitch) --- 
                let targetRollAmplitude, targetPitchAmplitude;
                if (arePelvicFinsVisible) {
                    targetRollAmplitude = pelvicStabilizedRollAmplitude;
                    targetPitchAmplitude = pelvicStabilizedPitchAmplitude;
                } else if (arePectoralFinsVisible) {
                    targetRollAmplitude = pectoralStabilizedRollAmplitude;
                    targetPitchAmplitude = pectoralStabilizedPitchAmplitude;
                } else {
                    targetRollAmplitude = baseRollAmplitude;
                    targetPitchAmplitude = basePitchAmplitude;
                }
                const rollAngle = targetRollAmplitude * Math.sin(rollFrequency * animationTime);
                const pitchAngle = targetPitchAmplitude * Math.cos(pitchFrequency * animationTime);
                fishMesh.rotation.z = rollAngle;
                fishMesh.rotation.x = pitchAngle;
                fishMesh.rotation.y = 0; // Reset yaw

                // --- Animate Tail (Vertex Deformation) --- 
                animateTailVertices(); // Call helper function
            }

            render();
        }

        // --- Update Particle Positions ---
        function updateParticlePositions() {
             if (!particleGeometry || !particles) return;

             const positions = particleGeometry.attributes.position.array;
             // Determine the multiplier for the Z velocity based on tail fin visibility
             let zVelocityMultiplier;
             if (isTailFinVisible) {
                 // Tail is ON: Calculate multiplier based on current fish speed
                 zVelocityMultiplier = 1.0 + (metrics.speed * particleSpeedFactor);
             } else {
                 // Tail is OFF: Use a very small multiplier to make particles visually almost stationary
                 zVelocityMultiplier = 0.01; // Adjust this value for desired minimal drift (0 = complete stop)
             }

             for (let i = 0; i < particleCount; i++) {
                 const i3 = i * 3;
                 const particlePos = new THREE.Vector3(positions[i3], positions[i3 + 1], positions[i3 + 2]);
                 const baseVelocity = particleVelocities[i]; // Get the base velocity stored

                 // Calculate effective velocity for this frame
                 const effectiveVelocity = baseVelocity.clone();
                 effectiveVelocity.z *= zVelocityMultiplier; // Scale ONLY forward speed based on tail state

                 // Apply effective velocity
                 particlePos.add(effectiveVelocity);

                 // Boundary Check: Reset particle if it goes out of bounds
                 if (!simulationBounds.containsPoint(particlePos)) {
                     // Reset position to spawn box
                     particlePos.x = THREE.MathUtils.randFloat(particleSpawnBox.min.x, particleSpawnBox.max.x);
                     particlePos.y = THREE.MathUtils.randFloat(particleSpawnBox.min.y, particleSpawnBox.max.y);
                     particlePos.z = THREE.MathUtils.randFloat(particleSpawnBox.min.z, particleSpawnBox.max.z);

                     // Reset velocity (use the BASE random velocity, it will be scaled next frame)
                     // Note: We don't scale the base velocity itself, only the effective velocity per frame.
                     baseVelocity.set(
                         THREE.MathUtils.randFloat(-0.008, 0.008),
                         THREE.MathUtils.randFloat(-0.008, 0.008),
                         THREE.MathUtils.randFloat(0.06, 0.12) // Reset base forward speed
                     );
                 }

                 // Update position attribute
                 positions[i3] = particlePos.x;
                 positions[i3 + 1] = particlePos.y;
                 positions[i3 + 2] = particlePos.z;
             }

             particleGeometry.attributes.position.needsUpdate = true; // Important!
        }

        // --- Render Function (Handles Viewports & Metrics) ---
        function render() {
            if (!renderer || !scene) return; // Exit if not initialized

            // --- NEW Metric Calculation --- 
            // Constants for scaling - THESE WILL LIKELY NEED TUNING!
            const FORM_DRAG_C1 = 0.3;     // Base coefficient for form drag
            const FRICTION_DRAG_C2 = 0.02;  // Base coefficient for friction drag
            const THRUST_C3 = 2.0;        // Base coefficient for thrust potential
            const SPEED_C4 = 0.5;         // Overall speed scaling factor (Reduced from 1.5)
            const PECTORAL_FIN_DRAG_ADDITION = 0.08; // Extra drag when pectoral fins are active
            const PELVIC_FIN_DRAG_ADDITION = 0.05;   // Extra drag when pelvic fins are active (can be same or different)

            // 1. Form Drag (based on cross-section and streamlining)
            // Less pointiness = less streamlining = more drag
            // Less roundness (more fusiform) = more streamlining = less drag
            let formDrag = FORM_DRAG_C1 * 
                           (controls.width * controls.height) * 
                           (1.5 - controls.pointiness) * 
                           (1.0 + Math.abs(controls.roundness - 0.5)); // Penalize deviation from ideal roundness?
            metrics.formDrag = Math.max(0.005, formDrag);

            // 2. Friction Drag (based on approximate surface area)
            // Approximating surface area: length * perimeter 
            let approxSurfaceArea = controls.length * (controls.width + controls.height) * 2;
            let frictionDrag = FRICTION_DRAG_C2 * approxSurfaceArea;
            
            // 3. Apply Mucus Effect (reduces friction drag)
            const mucusMultiplier = isMucusActive ? 0.3 : 1.0; 
            frictionDrag *= mucusMultiplier;
            metrics.frictionDrag = Math.max(0.005, frictionDrag);

            // 4. Total Drag
            metrics.totalDrag = metrics.formDrag + metrics.frictionDrag;
            // Add fin drag if they are visible
            if (arePectoralFinsVisible) {
                metrics.totalDrag += PECTORAL_FIN_DRAG_ADDITION;
            }
            if (arePelvicFinsVisible) {
                 metrics.totalDrag += PELVIC_FIN_DRAG_ADDITION;
            }

            // 5. Thrust Potential (based on tail fin size - squared for more impact)
            metrics.thrustPotential = isTailFinVisible ? (THRUST_C3 * Math.pow(controls.tailFinSize, 2)) : 0.001; // Minimal thrust if no tail
            
            // 6. Speed Calculation (Balance of Thrust vs Drag)
            metrics.speed = SPEED_C4 * metrics.thrustPotential / (1 + metrics.totalDrag);
            metrics.speed = Math.max(0.01, metrics.speed); // Ensure minimum speed

            // 7. Update fixed UI display
             if (frictionDisplayFixed) frictionDisplayFixed.textContent = metrics.totalDrag.toFixed(2);
             if (speedDisplayFixed) speedDisplayFixed.textContent = metrics.speed.toFixed(2);
            // --- End Metric Calculation ---


            renderer.setScissorTest(true);
            // Clear the entire canvas once with transparency. Viewport backgrounds are handled below.
            renderer.setClearColor(0x000000, 0);
            renderer.clear();

            const canvasRect = canvas.getBoundingClientRect();
            const simAreaWidth = simulationArea.clientWidth;
            const mobileBreakpoint = 1024; // Tailwind lg breakpoint
            const currentFrustumSize = simAreaWidth < mobileBreakpoint ? 4 : 5; // Smaller frustum (zoom in) on mobile

            // Define the background color for the viewports
            const viewportBackgroundColor = new THREE.Color(0x1a202c); // Same as scene bg

            for (const key in viewContainers) {
                const container = viewContainers[key];
                const camera = cameras[key];
                if (!container || !camera) continue;

                // Get the container's position and size relative to the viewport
                const rect = container.getBoundingClientRect();

                // Calculate viewport parameters relative to the canvas
                const relativeLeft = rect.left - canvasRect.left;
                // Calculate Y relative to canvas bottom edge for WebGL
                const relativeTop = rect.top - canvasRect.top;
                const webglY = canvasRect.height - relativeTop - rect.height;

                const width = rect.width;
                const height = rect.height;

                // Skip rendering if view has no size (e.g., during layout shifts)
                if (width <= 0 || height <= 0) continue;

                 // Determine effective frustum size for this camera view
                 let effectiveFrustumSize = currentFrustumSize;
                 // Apply extra zoom for front view ALWAYS (removed mobile check)
                 if (key === 'front') {
                     effectiveFrustumSize *= 0.7; // Apply MORE extra zoom for front view
                 }

                 // Update camera aspect ratio and projection based on container dimensions
                 camera.aspect = width / height;
                 const H = effectiveFrustumSize / 2; // Use effective size
                 const W = H * camera.aspect;
                 camera.left = -W;
                 camera.right = W;
                 camera.top = H;
                 camera.bottom = -H;
                 camera.updateProjectionMatrix();

                // Set the background color for this specific viewport
                renderer.setClearColor(viewportBackgroundColor, 1); // Opaque background for this view

                // Configure viewport and scissor for this view container
                renderer.setViewport(relativeLeft, webglY, width, height);
                renderer.setScissor(relativeLeft, webglY, width, height);
                renderer.clearDepth(); // Clear depth buffer before rendering this view

                // Render the scene with the correct camera for this viewport
                renderer.render(scene, camera);
            }

             renderer.setScissorTest(false); // Turn off scissor test after rendering all views
        }

        // --- Animate Tail Vertices (Deformation - Pivot around TIP) ---
        function animateTailVertices() {
            if (!isTailFinVisible || !fishMesh || !fishMesh.geometry || !originalAnimatedVertices || animatedVertexIndices.length === 0 || firstAnimatedVertexIndex < 0) {
                return; // Not ready, tail toggled off, or nothing to animate
            }

            const positions = fishMesh.geometry.attributes.position.array;
            const tailAngle = tailRotationAmplitude * Math.sin(tailFrequency * animationTime);

            // Define Pivot Z at the TIP of the tail fin
            const tailFinSize = controls.tailFinSize; // Get current size
            const pivotZ = controls.length * 0.5 - tailFinSize * 0.5;
            const pivotPoint = new THREE.Vector3(0, 0, pivotZ);

            // Define Base Z where blend factor should reach 1 (end of body / start of tail base)
            const baseZ = controls.length * 0.5;

            // Calculate the Z position where the animation starts blending
            const segmentsLength = 20; // Make sure this matches createFishGeometry
            const firstBodyAnimSegmentT = (segmentsLength - numBodyAnimSegments) / segmentsLength;
            const startAnimZ = (firstBodyAnimSegmentT - 0.5) * controls.length;

            // Blend range is now between start of animation and base of tail
            const blendRange = baseZ - startAnimZ;

            const rotationAxis = new THREE.Vector3(0, 1, 0); // Y-axis
            const quaternion = new THREE.Quaternion().setFromAxisAngle(rotationAxis, tailAngle);
            const tempVertex = new THREE.Vector3();
            const tempOriginalVertex = new THREE.Vector3();
            const tempVectorToPivot = new THREE.Vector3();

            for (let i = 0; i < animatedVertexIndices.length; i++) {
                const originalBufferIndex = i * 3;
                const liveBufferIndex = animatedVertexIndices[i] * 3;

                const x0 = originalAnimatedVertices[originalBufferIndex];
                const y0 = originalAnimatedVertices[originalBufferIndex + 1];
                const z0 = originalAnimatedVertices[originalBufferIndex + 2];
                tempOriginalVertex.set(x0, y0, z0);

                // Calculate blend factor (0 at startAnimZ, 1 at baseZ and beyond)
                let blendFactor = 0;
                if (blendRange > 0.01) { // Avoid division by zero
                     // Factor increases from 0 to 1 between startAnimZ and baseZ
                     blendFactor = Math.max(0, Math.min(1, (z0 - startAnimZ) / blendRange));
                }
                // Removed power curve for linear blend (can be added back if needed)
                // blendFactor = Math.pow(blendFactor, 1.5);

                // Calculate the fully rotated position AROUND THE TIP PIVOT
                tempVectorToPivot.subVectors(tempOriginalVertex, pivotPoint); // Vector from pivot to vertex
                tempVectorToPivot.applyQuaternion(quaternion); // Rotate this vector
                tempVertex.addVectors(pivotPoint, tempVectorToPivot); // Add back to pivot to get rotated position

                // Interpolate between original and fully rotated position using blendFactor
                // Vertices before startAnimZ have blendFactor 0 (no change)
                // Vertices between startAnimZ and baseZ blend smoothly
                // Vertices at/after baseZ (tail base and fin) have blendFactor 1 (full rotation relative to pivot)
                positions[liveBufferIndex]     = x0 + (tempVertex.x - x0) * blendFactor;
                positions[liveBufferIndex + 1] = y0 + (tempVertex.y - y0) * blendFactor;
                positions[liveBufferIndex + 2] = z0 + (tempVertex.z - z0) * blendFactor;
            }

            fishMesh.geometry.attributes.position.needsUpdate = true;
            fishMesh.geometry.computeVertexNormals();
        }

        // --- Start ---
        init();
        animate();

    </script>

</body>
</html> 
