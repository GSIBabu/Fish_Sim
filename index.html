<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>თევზის 3D სიმულაცია</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Basic styling for body and canvas */
        body {
            margin: 0;
            font-family: 'Segoe UI', 'Roboto', -apple-system, BlinkMacSystemFont, sans-serif;
            overflow: hidden; /* Prevent scrollbars */
            background-color: #f0f4f8; /* Light background */
            height: 100vh;
            display: flex;
        }
        #simulationCanvas {
            display: block; /* Remove extra space below canvas */
            width: 100%;
            height: 100%;
        }
        /* Custom styling for range sliders */
        input[type="range"] {
            -webkit-appearance: none; /* Override default look */
            appearance: none;
            width: 100%; /* Full width */
            height: 10px; /* Slightly thicker */
            background: linear-gradient(to right, #3b82f6, #60a5fa); /* Blue gradient */
            outline: none; /* Remove outline */
            border-radius: 9999px; /* Fully rounded */
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        input[type="range"]:hover {
            opacity: 1; /* Fully opaque on hover */
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; /* Override default look */
            appearance: none;
            width: 24px; /* Thumb width - larger */
            height: 24px; /* Thumb height - larger */
            background: #3b82f6; /* Blue thumb */
            cursor: pointer; /* Pointer cursor */
            border-radius: 50%; /* Circular thumb */
            box-shadow: 0 2px 6px rgba(59, 130, 246, 0.3); /* Subtle shadow */
            border: 2px solid white;
        }
        input[type="range"]::-moz-range-thumb {
            width: 24px; /* Thumb width - larger */
            height: 24px; /* Thumb height - larger */
            background: #3b82f6; /* Blue thumb */
            cursor: pointer; /* Pointer cursor */
            border-radius: 50%; /* Circular thumb */
            border: 2px solid white;
            box-shadow: 0 2px 6px rgba(59, 130, 246, 0.3); /* Subtle shadow */
        }
        /* Custom styling for toggle switch */
        .toggle-checkbox:checked {
            right: 0;
            border-color: #60a5fa; /* Blue border */
        }
        .toggle-checkbox:checked + .toggle-label {
            background-color: #60a5fa; /* Blue background */
        }
        
        /* View label styling */
        .view-label {
            position: absolute;
            background: linear-gradient(135deg, rgba(0,0,0,0.8) 0%, rgba(0,0,0,0.6) 100%);
            color: white;
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            letter-spacing: 0.5px;
            pointer-events: none;
            z-index: 10;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            backdrop-filter: blur(4px);
            border: 1px solid rgba(255,255,255,0.1);
        }
        
        /* Control panel styling */
        .control-panel {
            background: linear-gradient(135deg, #fff 0%, #f8fafc 100%);
            box-shadow: -5px 0 25px rgba(0,0,0,0.05);
            border-left: 1px solid rgba(0,0,0,0.05);
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }
        
        .control-header {
            color: #1e40af;
            font-weight: 700;
            letter-spacing: 0.5px;
            border-bottom: 2px solid #dbeafe;
            padding-bottom: 8px;
        }
        
        .metric-card {
            background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.05);
            border: 1px solid rgba(59, 130, 246, 0.1);
            transform: translateY(0);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        
        .metric-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(0,0,0,0.08);
        }
        
        /* Error message styling */
        #errorContainer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 100;
            backdrop-filter: blur(4px);
        }
        
        #errorMessage {
            background-color: white;
            padding: 24px;
            border-radius: 12px;
            max-width: 80%;
            text-align: center;
            box-shadow: 0 10px 25px rgba(0,0,0,0.2);
            font-weight: 500;
        }
        
        /* Loading indicator */
        #loadingContainer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 50;
            backdrop-filter: blur(8px);
        }
        
        .spinner {
            border: 5px solid rgba(255,255,255,0.2);
            border-radius: 50%;
            border-top: 5px solid #3498db;
            width: 60px;
            height: 60px;
            animation: spin 1s linear infinite;
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.3);
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Value indicators */
        .value-indicator {
            font-size: 14px;
            font-weight: 600;
            color: #4b5563;
            background-color: #f3f4f6;
            padding: 2px 6px;
            border-radius: 4px;
        }
        
        /* Metrics display - fixed within view */
        .metrics-display {
            position: absolute;
            top: 20px;
            z-index: 30;
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: none; /* Allow clicks to pass through */
        }
        
        .metric-badge {
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 15px;
            border-radius: 10px;
            backdrop-filter: blur(4px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            display: flex;
            justify-content: space-between;
            min-width: 180px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .metric-badge-value {
            font-weight: bold;
            font-size: 18px;
        }
        
        .metric-badge-label {
            opacity: 0.9;
        }
        
        /* Compact control panel design to avoid scrolling */
        .compact-controls {
            padding: 10px;
            gap: 10px;
            display: flex;
            flex-direction: column;
        }
        
        .control-group {
            margin-bottom: 8px;
        }
        
        .compact-slider {
            margin-bottom: 0;
            padding: 5px 0;
        }
        
        .compact-header {
            margin-bottom: 5px;
            font-size: 16px;
            padding-bottom: 5px;
        }
    </style>
</head>
<body class="flex flex-col md:flex-row h-screen">

    <div class="flex-grow relative h-1/2 md:h-full w-full">
        <canvas id="simulationCanvas"></canvas>
        <!-- View labels -->
        <div id="topViewLabel" class="view-label">ზედა ხედი</div>
        <div id="sideViewLabel" class="view-label">გვერდითი ხედი</div>
        <div id="frontViewLabel" class="view-label">წინა ხედი</div>
        
        <!-- Fixed metrics display -->
        <div class="metrics-display absolute top-4 right-4">
            <div class="metric-badge">
                <span class="metric-badge-label">ხახუნი:</span>
                <span id="frictionDisplayFixed" class="metric-badge-value">0.00</span>
            </div>
            <div class="metric-badge">
                <span class="metric-badge-label">სიჩქარე:</span>
                <span id="speedDisplayFixed" class="metric-badge-value">0.00</span>
            </div>
        </div>
        
        <!-- Loading indicator -->
        <div id="loadingContainer">
            <div class="spinner"></div>
        </div>
        
        <!-- Error message container -->
        <div id="errorContainer">
            <div id="errorMessage"></div>
        </div>
    </div>

    <div class="w-full md:w-72 h-auto md:h-full bg-white shadow-lg compact-controls control-panel border-t md:border-t-0 md:border-l border-gray-200">
        <h2 class="text-xl font-bold text-blue-800 compact-header control-header">მართვა</h2>

        <div class="control-group">
            <h3 class="text-lg font-semibold text-blue-700 mb-2">ფორმა</h3>
            <div class="compact-slider">
                <label for="lengthSlider" class="block text-sm font-medium text-gray-600">სიგრძე</label>
                <div class="flex items-center">
                    <input type="range" id="lengthSlider" min="1" max="5" value="3" step="0.1" class="flex-grow">
                    <span id="lengthValue" class="value-indicator ml-2">3.0</span>
                </div>
            </div>
            <div class="compact-slider">
                <label for="widthSlider" class="block text-sm font-medium text-gray-600">სიგანე</label>
                <div class="flex items-center">
                    <input type="range" id="widthSlider" min="0.2" max="1.5" value="0.5" step="0.05" class="flex-grow">
                    <span id="widthValue" class="value-indicator ml-2">0.5</span>
                </div>
            </div>
            <div class="compact-slider">
                <label for="heightSlider" class="block text-sm font-medium text-gray-600">სიმაღლე</label>
                <div class="flex items-center">
                    <input type="range" id="heightSlider" min="0.2" max="1.5" value="0.4" step="0.05" class="flex-grow">
                    <span id="heightValue" class="value-indicator ml-2">0.4</span>
                </div>
            </div>
            <div class="compact-slider">
                <label for="pointinessSlider" class="block text-sm font-medium text-gray-600">კუდის წვეტიანობა</label>
                <div class="flex items-center">
                    <input type="range" id="pointinessSlider" min="0.1" max="1" value="0.5" step="0.05" class="flex-grow">
                    <span id="pointinessValue" class="value-indicator ml-2">0.5</span>
                </div>
            </div>
            <div class="compact-slider">
                <label for="roundnessSlider" class="block text-sm font-medium text-gray-600">სიმრგვალე (სხეული)</label>
                <div class="flex items-center">
                    <input type="range" id="roundnessSlider" min="0.1" max="1" value="0.6" step="0.05" class="flex-grow">
                    <span id="roundnessValue" class="value-indicator ml-2">0.6</span>
                </div>
            </div>
        </div>

        <div class="control-group mt-4 border-t pt-3">
            <h3 class="text-lg font-semibold text-blue-700 mb-2">ფიზიკა</h3>
            <div class="flex items-center justify-between">
                <label for="mucusToggle" class="text-sm font-medium text-gray-600">ლორწოს გამოყოფა</label>
                <div class="relative inline-block w-12 mr-2 align-middle select-none transition duration-200 ease-in">
                    <input type="checkbox" name="mucusToggle" id="mucusToggle" class="toggle-checkbox absolute block w-6 h-6 rounded-full bg-white border-4 appearance-none cursor-pointer"/>
                    <label for="mucusToggle" class="toggle-label block overflow-hidden h-6 rounded-full bg-gray-300 cursor-pointer"></label>
                </div>
            </div>
        </div>

        <div class="text-sm text-gray-500 text-center mt-4 italic px-2">
            გამარტივებული სითხის სიმულაცია. მეტრიკები შეფარდებითია.
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- Global Variables ---
        let scene, renderer, cameraTop, cameraSide, cameraFront;
        let frustumSize;
        let fishMesh, fishMaterial;
        let particles, particleGeometry, particleMaterial;
        let controls = {}; // To store slider/toggle values
        let metrics = { friction: 0, speed: 1 }; // Default metrics
        let isMucusActive = false;
        const particleCount = 2000;
        const particleVelocities = []; // Store individual velocities
        const particleSpawnBox = new THREE.Box3(
            new THREE.Vector3(-5, -3, -10),
            new THREE.Vector3(5, 3, -8)
        );
        const simulationBounds = new THREE.Box3(
            new THREE.Vector3(-6, -4, -12),
            new THREE.Vector3(6, 4, 10)
        );
        let fishBoundingBox = new THREE.Box3(); // For simplified collision
        let animationFrameId; // For canceling animation loop
        
        // View settings
        const viewPadding = 20; // Padding between views in pixels
        const viewportInfo = {
            top: { x: 0, y: 0, width: 0, height: 0 },
            side: { x: 0, y: 0, width: 0, height: 0 },
            front: { x: 0, y: 0, width: 0, height: 0 }
        };

        // --- Helper Functions ---
        function safeGetElement(id) {
            const element = document.getElementById(id);
            if (!element) {
                console.warn(`Element with id ${id} not found`);
                return null;
            }
            return element;
        }
        
        function showError(message) {
            const errorContainer = safeGetElement('errorContainer');
            const errorMessage = safeGetElement('errorMessage');
            
            if (errorContainer && errorMessage) {
                errorMessage.textContent = message;
                errorContainer.style.display = 'flex';
            } else {
                alert(message); // Fallback if error elements don't exist
            }
        }
        
        function hideLoading() {
            const loadingContainer = safeGetElement('loadingContainer');
            if (loadingContainer) {
                loadingContainer.style.display = 'none';
            }
        }

        // --- UI Element References ---
        const lengthSlider = safeGetElement('lengthSlider');
        const widthSlider = safeGetElement('widthSlider');
        const heightSlider = safeGetElement('heightSlider');
        const pointinessSlider = safeGetElement('pointinessSlider');
        const roundnessSlider = safeGetElement('roundnessSlider');
        const mucusToggle = safeGetElement('mucusToggle');
        const lengthValueSpan = safeGetElement('lengthValue');
        const widthValueSpan = safeGetElement('widthValue');
        const heightValueSpan = safeGetElement('heightValue');
        const pointinessValueSpan = safeGetElement('pointinessValue');
        const roundnessValueSpan = safeGetElement('roundnessValue');
        const frictionDisplay = safeGetElement('frictionDisplay');
        const speedDisplay = safeGetElement('speedDisplay');
        const frictionDisplayFixed = safeGetElement('frictionDisplayFixed');
        const speedDisplayFixed = safeGetElement('speedDisplayFixed');
        const canvas = safeGetElement('simulationCanvas');
        const canvasContainer = canvas?.parentElement; // Get container for size
        
        // View label elements
        const topViewLabel = safeGetElement('topViewLabel');
        const sideViewLabel = safeGetElement('sideViewLabel');
        const frontViewLabel = safeGetElement('frontViewLabel');

        // --- Check WebGL Support ---
        function checkWebGLSupport() {
            try {
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('webgl2') || 
                                canvas.getContext('webgl') || 
                                canvas.getContext('experimental-webgl');
                
                if (!context) {
                    throw new Error('WebGL მხარდაჭერა არ არის');
                }
                
                return true;
            } catch (e) {
                showError('თქვენს ბრაუზერში WebGL არ არის მხარდაჭერილი. გთხოვთ სცადოთ სხვა ბრაუზერი ან მოწყობილობა.');
                return false;
            }
        }

        // --- Update Viewports ---
        function updateViewports() {
            if (!canvasContainer) return;
            
            const width = canvasContainer.clientWidth;
            const height = canvasContainer.clientHeight;
            
            // More precise calculation to ensure viewports fit
            const topHeight = Math.floor((height - viewPadding * 3) * 0.5);
            const bottomHeight = Math.floor((height - viewPadding * 3) * 0.5);
            const halfWidth = Math.floor((width - viewPadding * 3) / 2);
            
            // Update viewport information
            viewportInfo.top = {
                x: viewPadding,
                y: viewPadding,
                width: width - (viewPadding * 2),
                height: topHeight
            };
            
            viewportInfo.side = {
                x: viewPadding,
                y: topHeight + (viewPadding * 2),
                width: halfWidth,
                height: bottomHeight
            };
            
            viewportInfo.front = {
                x: halfWidth + (viewPadding * 2),
                y: topHeight + (viewPadding * 2),
                width: halfWidth,
                height: bottomHeight
            };
        }
        
        // --- Update View Labels ---
        function updateViewLabels() {
            // Position the labels within each viewport and enhance their visibility
            if (topViewLabel) {
                topViewLabel.style.left = `${viewportInfo.top.x + 10}px`;
                topViewLabel.style.top = `${viewportInfo.top.y + 10}px`;
                topViewLabel.style.fontSize = '14px'; // Larger font
                topViewLabel.style.padding = '6px 10px'; // More padding
                topViewLabel.style.backgroundColor = 'rgba(0,0,0,0.7)'; // Darker background for better contrast
            }
            
            if (sideViewLabel) {
                sideViewLabel.style.left = `${viewportInfo.side.x + 10}px`;
                sideViewLabel.style.top = `${viewportInfo.side.y + 10}px`;
                sideViewLabel.style.fontSize = '14px';
                sideViewLabel.style.padding = '6px 10px';
                sideViewLabel.style.backgroundColor = 'rgba(0,0,0,0.7)';
            }
            
            if (frontViewLabel) {
                frontViewLabel.style.left = `${viewportInfo.front.x + 10}px`;
                frontViewLabel.style.top = `${viewportInfo.front.y + 10}px`;
                frontViewLabel.style.fontSize = '14px';
                frontViewLabel.style.padding = '6px 10px';
                frontViewLabel.style.backgroundColor = 'rgba(0,0,0,0.7)';
            }
        }

        // --- Initialization ---
        function init() {
            // Check WebGL support first
            if (!checkWebGLSupport() || !canvas || !canvasContainer) {
                return false;
            }
            
            try {
                // Scene
                scene = new THREE.Scene();
                scene.background = null; // Remove scene background - use only renderer background
    
                // Renderer
                renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.setSize(canvasContainer.clientWidth, canvasContainer.clientHeight);
                renderer.setClearColor(0x1e293b); // Dark slate blue background for the canvas
                renderer.setScissorTest(true); // Enable scissoring for multiple views
    
                // Lighting
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
                scene.add(ambientLight);
                const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
                directionalLight.position.set(5, 10, 7.5);
                scene.add(directionalLight);
    
                // Cameras (Orthographic for views)
                frustumSize = 5; // Controls zoom level
                
                // Calculate initial viewports
                updateViewports();
                
                // Create cameras with proper aspect ratios
                const aspectTop = viewportInfo.top.width / viewportInfo.top.height;
                const aspectSide = viewportInfo.side.width / viewportInfo.side.height;
                const aspectFront = viewportInfo.front.width / viewportInfo.front.height;
                
                // Position and orient cameras for the clearest distinct views
                
                // Top view camera - looking down from above (Y-axis)
                cameraTop = new THREE.OrthographicCamera(
                    frustumSize * aspectTop / -2, frustumSize * aspectTop / 2,
                    frustumSize / 2, frustumSize / -2,
                    0.1, 100
                );
                cameraTop.position.set(0, 10, 0); // Position directly above
                cameraTop.lookAt(0, 0, 0);
                cameraTop.zoom = 0.8;
                cameraTop.updateProjectionMatrix();
                scene.add(cameraTop);
    
                // Side view camera - looking from the side (X-axis)
                cameraSide = new THREE.OrthographicCamera(
                    frustumSize * aspectSide / -2, frustumSize * aspectSide / 2,
                    frustumSize / 2, frustumSize / -2,
                    0.1, 100
                );
                cameraSide.position.set(10, 0, 0); // Position directly to the side
                cameraSide.lookAt(0, 0, 0);
                cameraSide.zoom = 0.8;
                cameraSide.updateProjectionMatrix();
                scene.add(cameraSide);
    
                // Front view camera - looking at the fish head-on (Z-axis)
                // Rotate the fish 90 degrees in this view
                cameraFront = new THREE.OrthographicCamera(
                    frustumSize * aspectFront / -2, frustumSize * aspectFront / 2,
                    frustumSize / 2, frustumSize / -2,
                    0.1, 100
                );
                cameraFront.position.set(0, 0, -10); // Position in front of the fish
                cameraFront.lookAt(0, 0, 0);
                cameraFront.zoom = 0.8;
                // Add rotation matrix to rotate the fish 90 degrees in this view
                cameraFront.up.set(0, 0, 1); // This rotates the camera's "up" direction
                cameraFront.updateProjectionMatrix();
                scene.add(cameraFront);
    
                // Fish Material
                fishMaterial = new THREE.MeshStandardMaterial({
                    color: 0xff4500, // Orangey-red
                    metalness: 0.3,
                    roughness: 0.6,
                    side: THREE.DoubleSide, // Render both sides of faces
                });
    
                // Initial Fish Object
                updateShape(); // Create fish based on initial slider values
    
                // Particle System
                createParticles();
    
                // Event Listeners - with null checks
                if (lengthSlider) lengthSlider.addEventListener('input', handleSliderChange);
                if (widthSlider) widthSlider.addEventListener('input', handleSliderChange);
                if (heightSlider) heightSlider.addEventListener('input', handleSliderChange);
                if (pointinessSlider) pointinessSlider.addEventListener('input', handleSliderChange);
                if (roundnessSlider) roundnessSlider.addEventListener('input', handleSliderChange);
                if (mucusToggle) mucusToggle.addEventListener('change', updatePhysicsParameters);
                window.addEventListener('resize', onWindowResize);
                window.addEventListener('beforeunload', cleanup);
    
                // Initial UI Update
                updateControlValues();
                updatePhysicsParameters(); // Set initial mucus state
                updateViewLabels(); // Set view labels
                
                // Hide loading indicator
                hideLoading();
                
                return true;
            } catch (error) {
                console.error("Initialization error:", error);
                showError(`Failed to initialize simulation: ${error.message}`);
                return false;
            }
        }
        
        // --- Cleanup Function ---
        function cleanup() {
            // Cancel animation frame
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            
            // Remove event listeners
            window.removeEventListener('resize', onWindowResize);
            if (lengthSlider) lengthSlider.removeEventListener('input', handleSliderChange);
            if (widthSlider) widthSlider.removeEventListener('input', handleSliderChange);
            if (heightSlider) heightSlider.removeEventListener('input', handleSliderChange);
            if (pointinessSlider) pointinessSlider.removeEventListener('input', handleSliderChange);
            if (roundnessSlider) roundnessSlider.removeEventListener('input', handleSliderChange);
            if (mucusToggle) mucusToggle.removeEventListener('change', updatePhysicsParameters);
            window.removeEventListener('beforeunload', cleanup);
            
            // Dispose Three.js objects
            if (particleGeometry) particleGeometry.dispose();
            if (particleMaterial) particleMaterial.dispose();
            if (fishMesh && fishMesh.geometry) fishMesh.geometry.dispose();
            if (fishMaterial) fishMaterial.dispose();
            
            // Remove objects from scene
            if (scene) {
                if (fishMesh) scene.remove(fishMesh);
                if (particles) scene.remove(particles);
                // Remove cameras
                if (cameraTop) scene.remove(cameraTop);
                if (cameraSide) scene.remove(cameraSide);
                if (cameraFront) scene.remove(cameraFront);
            }
            
            // Dispose of renderer
            if (renderer) {
                renderer.dispose();
            }
        }

        // --- Create Fish Geometry ---
        function createFishGeometry(length, width, height, pointiness, roundness) {
            // Instead of using LatheGeometry which creates a rotationally symmetric shape,
            // Let's create a more realistic fish shape with distinct top/side profiles

            // Create base geometry for the fish body
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            const indices = [];
            
            // Parameters to control the fish shape
            const bodyLength = length;
            const bodyWidth = width;     // Width controls horizontal (X-axis) dimension
            const bodyHeight = height;   // Height controls vertical (Y-axis) dimension
            const tailFinSize = height * 0.8; // Scale tail with height instead of width
            const dorsalFinHeight = height * 0.5;
            
            // Resolution of the fish mesh
            const segmentsLength = 20;
            const segmentsCircumference = 16;
            
            // Create the oval-shaped body of the fish
            for (let i = 0; i <= segmentsLength; i++) {
                const z = (i / segmentsLength - 0.5) * bodyLength; // Position along length
                const t = i / segmentsLength; // Normalized position
                
                // Make the body taper at both ends, more sharply at the nose based on pointiness
                const radiusMultiplier = Math.sin(Math.PI * t);
                const pointinessEffect = (1 - (1 - pointiness) * Math.pow(t, 4));
                const roundnessEffect = 1 + (roundness - 0.5) * Math.sin(Math.PI * t * 2) * 0.5;
                
                // Calculate width and height at this segment
                const segmentWidth = bodyWidth * radiusMultiplier * pointinessEffect * roundnessEffect;
                const segmentHeight = bodyHeight * radiusMultiplier * pointinessEffect * roundnessEffect;
                
                // Create vertices around the circumference at this segment
                for (let j = 0; j < segmentsCircumference; j++) {
                    const theta = (j / segmentsCircumference) * Math.PI * 2;
                    
                    // Use separate width and height parameters to create an elliptical cross-section
                    const x = segmentWidth * Math.cos(theta);
                    let y = segmentHeight * Math.sin(theta);
                    
                    // Flatten the bottom slightly
                    if (y < 0) {
                        y = y * 0.7;
                    }
                    
                    // Add dorsal fin on top
                    if (j === 0 && i > segmentsLength * 0.3 && i < segmentsLength * 0.6) {
                        y += dorsalFinHeight * Math.sin((i / segmentsLength - 0.3) * Math.PI);
                    }
                    
                    vertices.push(x, y, z);
                }
            }
            
            // Create faces between adjacent segments
            for (let i = 0; i < segmentsLength; i++) {
                for (let j = 0; j < segmentsCircumference; j++) {
                    const current = i * segmentsCircumference + j;
                    const next = i * segmentsCircumference + (j + 1) % segmentsCircumference;
                    const nextRow = (i + 1) * segmentsCircumference + j;
                    const nextRowNext = (i + 1) * segmentsCircumference + (j + 1) % segmentsCircumference;
                    
                    // Create two triangular faces
                    indices.push(current, next, nextRowNext);
                    indices.push(current, nextRowNext, nextRow);
                }
            }
            
            // Fix the tail orientation: keep at positive Z but point backwards
            const tailBaseZ = bodyLength * 0.5; // Position at the original location (positive Z)
            const tailBaseIndex = vertices.length / 3;
            
            // Create the tail fin as a vertical fan shape, but pointing backwards
            vertices.push(0, -tailFinSize/2, tailBaseZ); // Bottom of tail fin
            vertices.push(0, 0, tailBaseZ - tailFinSize * 0.5); // Middle point of tail (points backwards)
            vertices.push(0, tailFinSize/2, tailBaseZ); // Top of tail fin
            
            // Create tail fin face
            indices.push(tailBaseIndex, tailBaseIndex + 1, tailBaseIndex + 2);
            
            // Set geometry attributes
            geometry.setIndex(indices);
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            
            // Compute normals for proper lighting
            geometry.computeVertexNormals();
            
            return geometry;
        }


        // --- Create Particle System ---
        function createParticles() {
            const positions = new Float32Array(particleCount * 3);

            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                // Random position within the spawn box
                positions[i3] = THREE.MathUtils.randFloat(particleSpawnBox.min.x, particleSpawnBox.max.x);
                positions[i3 + 1] = THREE.MathUtils.randFloat(particleSpawnBox.min.y, particleSpawnBox.max.y);
                positions[i3 + 2] = THREE.MathUtils.randFloat(particleSpawnBox.min.z, particleSpawnBox.max.z);

                // Initialize velocity (mostly forward in Z)
                particleVelocities.push(new THREE.Vector3(
                    THREE.MathUtils.randFloat(-0.005, 0.005), // Slight sideways drift
                    THREE.MathUtils.randFloat(-0.005, 0.005), // Slight vertical drift
                    THREE.MathUtils.randFloat(0.05, 0.1)      // Forward speed
                ));
            }

            particleGeometry = new THREE.BufferGeometry();
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

            // Increased particle size and changed color for better visibility
            particleMaterial = new THREE.PointsMaterial({
                color: 0x00ffff, // Cyan for better visibility against dark background
                size: 0.25, // Significantly increased size for better visibility
                sizeAttenuation: true, // Smaller when further away
                transparent: true,
                opacity: 1.0 // Full opacity for better visibility
            });

            particles = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particles);
            
            // Add visual references to help understand orientation
            const axisHelperSize = 3;
            const axisHelper = new THREE.AxesHelper(axisHelperSize);
            scene.add(axisHelper);
            
            // Add XZ grid (floor)
            const gridHelper = new THREE.GridHelper(10, 10);
            scene.add(gridHelper);
            
            // Add XY grid (wall)
            const gridHelper2 = new THREE.GridHelper(10, 10);
            gridHelper2.rotation.x = Math.PI / 2;
            gridHelper2.position.z = -5;
            scene.add(gridHelper2);
            
            // Add YZ grid (side wall)
            const gridHelper3 = new THREE.GridHelper(10, 10);
            gridHelper3.rotation.z = Math.PI / 2;
            gridHelper3.position.x = -5;
            scene.add(gridHelper3);
        }

        // --- Update Shape ---
        function updateShape() {
            if (!lengthSlider || !widthSlider || !heightSlider || !pointinessSlider || !roundnessSlider) {
                console.warn("Missing UI sliders, cannot update shape");
                return;
            }
            
            // Read current values from sliders
            controls.length = parseFloat(lengthSlider.value);
            controls.width = parseFloat(widthSlider.value);
            controls.height = parseFloat(heightSlider.value);
            controls.pointiness = parseFloat(pointinessSlider.value);
            controls.roundness = parseFloat(roundnessSlider.value);

            try {
                // Create new geometry
                const newGeometry = createFishGeometry(
                    controls.length,
                    controls.width,
                    controls.height,
                    controls.pointiness,
                    controls.roundness
                );
    
                if (fishMesh) {
                    // Dispose old geometry to prevent memory leaks
                    fishMesh.geometry.dispose();
                    // Assign new geometry
                    fishMesh.geometry = newGeometry;
                } else {
                    // Create mesh if it doesn't exist
                    fishMesh = new THREE.Mesh(newGeometry, fishMaterial);
                    scene.add(fishMesh);
                }
    
                // Update the simplified bounding box for collision
                fishMesh.geometry.computeBoundingBox();
                // Important: Update world matrix before getting bounding box from object
                fishMesh.updateMatrixWorld(true);
                fishBoundingBox.copy(fishMesh.geometry.boundingBox).applyMatrix4(fishMesh.matrixWorld);
    
                // Update UI display for slider values
                updateControlValues();
            } catch (error) {
                console.error("Error updating fish shape:", error);
            }
        }

        // --- Update Physics Parameters (Mucus Toggle) ---
        function updatePhysicsParameters() {
            if (mucusToggle) {
                isMucusActive = mucusToggle.checked;
            }
            // The effect is applied during metric calculation and particle interaction
        }

         // --- Update UI Control Value Displays ---
                 function updateControlValues() {
            if (lengthValueSpan) lengthValueSpan.textContent = controls.length.toFixed(1);
            if (widthValueSpan) widthValueSpan.textContent = controls.width.toFixed(2);
            if (heightValueSpan) heightValueSpan.textContent = controls.height.toFixed(2);
            if (pointinessValueSpan) pointinessValueSpan.textContent = controls.pointiness.toFixed(2);
            if (roundnessValueSpan) roundnessValueSpan.textContent = controls.roundness.toFixed(2);
        }


        // --- Handle Slider Changes ---
        function handleSliderChange(event) {
            updateShape(); // Update geometry when any shape slider changes
            // Note: Metrics are calculated in the animation loop based on current shape/params
        }

        // --- Animation Loop ---
        function animate() {
            animationFrameId = requestAnimationFrame(animate);
            
            if (!particleGeometry || !fishMesh) return;

            const positions = particleGeometry.attributes.position.array;
            let collisionCount = 0;
            let totalPostInteractionSpeed = 0;
            let particlesCountedForSpeed = 0;

            // Update particle positions and check for collisions/boundaries
            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                const particlePos = new THREE.Vector3(positions[i3], positions[i3 + 1], positions[i3 + 2]);
                const velocity = particleVelocities[i];

                // Apply velocity
                particlePos.add(velocity);

                let collided = false;
                // Simplified Collision Check (Bounding Box)
                if (fishBoundingBox.containsPoint(particlePos)) {
                    collided = true;
                    collisionCount++;

                    // Simplified Interaction: Deflect particle slightly away from center
                    const deflectionStrength = isMucusActive ? 0.01 : 0.05; // Less deflection with mucus
                    const directionToCenter = particlePos.clone().multiplyScalar(-1).normalize(); // Direction towards origin
                    velocity.add(directionToCenter.multiplyScalar(deflectionStrength));

                    // Dampen forward velocity slightly on collision
                     velocity.z *= isMucusActive ? 0.98 : 0.9;
                }

                // Boundary Check: Reset particle if it goes out of bounds
                if (!simulationBounds.containsPoint(particlePos)) {
                    // Reset position to spawn box
                    particlePos.x = THREE.MathUtils.randFloat(particleSpawnBox.min.x, particleSpawnBox.max.x);
                    particlePos.y = THREE.MathUtils.randFloat(particleSpawnBox.min.y, particleSpawnBox.max.y);
                    particlePos.z = THREE.MathUtils.randFloat(particleSpawnBox.min.z, particleSpawnBox.max.z);

                    // Reset velocity
                    velocity.set(
                        THREE.MathUtils.randFloat(-0.005, 0.005),
                        THREE.MathUtils.randFloat(-0.005, 0.005),
                        THREE.MathUtils.randFloat(0.05, 0.1) // Reset forward speed
                    );
                } else {
                     // Only count speed for particles past the object's approximate center
                     if (particlePos.z > fishBoundingBox.max.z) {
                        totalPostInteractionSpeed += velocity.z;
                        particlesCountedForSpeed++;
                     }
                }

                // Update position attribute
                positions[i3] = particlePos.x;
                positions[i3 + 1] = particlePos.y;
                positions[i3 + 2] = particlePos.z;
            }

            particleGeometry.attributes.position.needsUpdate = true; // Important!

            // --- Calculate Metrics (Simplified) ---
            // Friction: Based on shape parameters and collision count, reduced by mucus
            const shapeFactor = (controls.width * 2) * (1.5 - controls.pointiness) * controls.roundness; // Example formula
            const baseFriction = 0.1 + shapeFactor * 0.5; // Base friction related to shape size/form
            const collisionFriction = (collisionCount / particleCount) * 5; // Friction from direct hits
            const mucusMultiplier = isMucusActive ? 0.3 : 1.0; // Mucus reduces friction significantly

            metrics.friction = (baseFriction + collisionFriction) * mucusMultiplier;
            metrics.friction = Math.max(0.01, metrics.friction); // Ensure friction doesn't go to zero

            // Speed: Based on average particle speed after interaction zone, inversely related to friction
            const avgSpeed = particlesCountedForSpeed > 0 ? totalPostInteractionSpeed / particlesCountedForSpeed : 0.07; // Use default if no particles counted
            // Map avgSpeed (which is small) to a 0-1+ range, inversely affected by friction
            metrics.speed = (avgSpeed * 10) / (1 + metrics.friction * 2); // Example formula
            metrics.speed = Math.max(0.01, metrics.speed); // Ensure speed doesn't go to zero

            // Update UI Displays
            if (frictionDisplay) frictionDisplay.textContent = metrics.friction.toFixed(2);
            if (speedDisplay) speedDisplay.textContent = metrics.speed.toFixed(2);

            // --- Render ---
            render();
        }

        // --- Render Function (Handles Viewports) ---
        function render() {
            if (!renderer || !canvasContainer) return;
            
            renderer.setScissorTest(true); // Ensure scissoring is enabled

            // Render Top View (Top)
            renderer.setViewport(
                viewportInfo.top.x,
                viewportInfo.top.y,
                viewportInfo.top.width,
                viewportInfo.top.height
            );
            renderer.setScissor(
                viewportInfo.top.x,
                viewportInfo.top.y,
                viewportInfo.top.width,
                viewportInfo.top.height
            );
            if (cameraTop) renderer.render(scene, cameraTop);

            // Render Side View (Bottom Left)
            renderer.setViewport(
                viewportInfo.side.x,
                viewportInfo.side.y,
                viewportInfo.side.width,
                viewportInfo.side.height
            );
            renderer.setScissor(
                viewportInfo.side.x,
                viewportInfo.side.y,
                viewportInfo.side.width,
                viewportInfo.side.height
            );
            if (cameraSide) renderer.render(scene, cameraSide);

            // Render Front View (Bottom Right)
            renderer.setViewport(
                viewportInfo.front.x,
                viewportInfo.front.y,
                viewportInfo.front.width,
                viewportInfo.front.height
            );
            renderer.setScissor(
                viewportInfo.front.x,
                viewportInfo.front.y,
                viewportInfo.front.width,
                viewportInfo.front.height
            );
            if (cameraFront) renderer.render(scene, cameraFront);
            
            renderer.setScissorTest(false); // Disable scissoring after rendering
        }

        // --- Resize Handler ---
        function onWindowResize() {
            if (!renderer || !canvasContainer) return;
            
            const width = canvasContainer.clientWidth;
            const height = canvasContainer.clientHeight;

            renderer.setSize(width, height);
            
            // Update viewport sizes and positions
            updateViewports();
            
            // Update camera aspect ratios and projection matrices
            const aspectTop = viewportInfo.top.width / viewportInfo.top.height;
            const aspectSide = viewportInfo.side.width / viewportInfo.side.height;
            const aspectFront = viewportInfo.front.width / viewportInfo.front.height;

            // Update top camera
            if (cameraTop) {
                cameraTop.left = frustumSize * aspectTop / -2;
                cameraTop.right = frustumSize * aspectTop / 2;
                cameraTop.top = frustumSize / 2;
                cameraTop.bottom = frustumSize / -2;
                // Keep the zoom setting
                cameraTop.updateProjectionMatrix();
            }

            // Update side camera
            if (cameraSide) {
                cameraSide.left = frustumSize * aspectSide / -2;
                cameraSide.right = frustumSize * aspectSide / 2;
                cameraSide.top = frustumSize / 2;
                cameraSide.bottom = frustumSize / -2;
                // Keep the zoom setting
                cameraSide.updateProjectionMatrix();
            }

            // Update front camera
            if (cameraFront) {
                cameraFront.left = frustumSize * aspectFront / -2;
                cameraFront.right = frustumSize * aspectFront / 2;
                cameraFront.top = frustumSize / 2;
                cameraFront.bottom = frustumSize / -2;
                // Keep the zoom setting
                cameraFront.updateProjectionMatrix();
            }
            
            // Update view labels
            updateViewLabels();
        }

                    // Create fish based on initial slider values
            if (init()) {
                // Further enhance the visuals by rotating the fish to match camera views better
                if (fishMesh) {
                    // Orient fish along Z-axis with nose pointing toward positive Z
                    // No need to rotate as the LatheGeometry already creates it this way
                }
                animate(); // Start the loop only if initialization succeeded
            }
    </script>

</body>
</html>