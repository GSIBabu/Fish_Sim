<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trout OBJ Viewer - Three Views</title>
    <style>
        body {
            margin: 0;
            overflow: hidden; /* Prevent scrollbars */
            background-color: #f0f4f8; /* Light background */
            height: 100vh;
            display: flex; /* Use flex for potential future layout adjustments */
        }
        #viewerCanvas {
            display: block;
            width: 100%;
            height: 100%;
        }
         /* Basic view label styling */
        .view-label {
            position: absolute;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 12px;
            font-family: sans-serif;
            font-weight: bold;
            pointer-events: none;
            z-index: 10;
        }
    </style>
</head>
<body>
    <div style="position: relative; width: 100%; height: 100%;">
        <canvas id="viewerCanvas"></canvas>
        <!-- View labels -->
        <div id="topViewLabel" class="view-label">Top View</div>
        <div id="sideViewLabel" class="view-label">Side View</div>
        <div id="frontViewLabel" class="view-label">Front View</div>
         <!-- Loading indicator -->
        <div id="loadingIndicator" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #333; background: rgba(255,255,255,0.8); padding: 15px; border-radius: 8px; font-family: sans-serif; display: none;">Loading Model...</div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.163.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';

        let scene, renderer, canvas, canvasContainer;
        let cameraTop, cameraSide, cameraFront;
        let loadedObject = null;
        let animationFrameId;

        const viewPadding = 15; // Padding between views in pixels
        const viewportInfo = {
            top: { x: 0, y: 0, width: 0, height: 0 },
            side: { x: 0, y: 0, width: 0, height: 0 },
            front: { x: 0, y: 0, width: 0, height: 0 }
        };

        // --- UI Elements ---
        const topViewLabel = document.getElementById('topViewLabel');
        const sideViewLabel = document.getElementById('sideViewLabel');
        const frontViewLabel = document.getElementById('frontViewLabel');
        const loadingIndicator = document.getElementById('loadingIndicator');

        // --- Initialization ---
        function init() {
            canvas = document.getElementById('viewerCanvas');
            canvasContainer = canvas.parentElement;

            if (!canvas || !canvasContainer) {
                console.error("Canvas or container not found.");
                return;
            }

            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1e293b); // Dark slate blue background

             // Add Grid Helpers for orientation
            const gridXZ = new THREE.GridHelper(100, 10);
            scene.add(gridXZ);
            const gridXY = new THREE.GridHelper(100, 10);
            gridXY.rotation.x = Math.PI / 2;
            scene.add(gridXY);
            const gridYZ = new THREE.GridHelper(100, 10);
            gridYZ.rotation.z = Math.PI / 2;
            scene.add(gridYZ);

            // Renderer
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(canvasContainer.clientWidth, canvasContainer.clientHeight);
            renderer.setScissorTest(true); // Enable scissoring for multiple views

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 1.5); // Brighter ambient
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
            directionalLight.position.set(50, 100, 75); // Adjust light position based on expected model scale
            scene.add(directionalLight);
            const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight2.position.set(-50, -50, -75);
            scene.add(directionalLight2);

            // Cameras (Orthographic for views)
            const frustumSize = 50; // Adjust this based on model size

            updateViewports(); // Calculate initial viewports

            // --- Create Cameras ---
            // NOTE: Aspect ratio needs to be updated on resize
            const aspectTop = viewportInfo.top.width / viewportInfo.top.height;
            const aspectSide = viewportInfo.side.width / viewportInfo.side.height;
            const aspectFront = viewportInfo.front.width / viewportInfo.front.height;

            // Top view (looking down Y)
            cameraTop = new THREE.OrthographicCamera(
                frustumSize * aspectTop / -2, frustumSize * aspectTop / 2,
                frustumSize / 2, frustumSize / -2,
                0.1, 1000 // Adjust near/far clipping
            );
            cameraTop.position.set(0, 100, 0); // Position above
            cameraTop.lookAt(0, 0, 0);
            cameraTop.updateProjectionMatrix();

            // Side view (looking along X)
            cameraSide = new THREE.OrthographicCamera(
                frustumSize * aspectSide / -2, frustumSize * aspectSide / 2,
                frustumSize / 2, frustumSize / -2,
                0.1, 1000
            );
            cameraSide.position.set(100, 0, 0); // Position to the side
            cameraSide.lookAt(0, 0, 0);
            cameraSide.updateProjectionMatrix();

            // Front view (looking along Z)
            cameraFront = new THREE.OrthographicCamera(
                frustumSize * aspectFront / -2, frustumSize * aspectFront / 2,
                frustumSize / 2, frustumSize / -2,
                0.1, 1000
            );
            cameraFront.position.set(0, 0, 100); // Position in front
            cameraFront.lookAt(0, 0, 0);
             // cameraFront.up.set(0, 1, 0); // Default up is Y
            cameraFront.updateProjectionMatrix();

            // --- Load OBJ Model ---
            loadModel();

            // --- Event Listeners ---
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('beforeunload', cleanup); // Cleanup on page close

            updateViewLabels(); // Position labels initially
        }

        // --- Load Model ---
        function loadModel() {
            if (loadingIndicator) loadingIndicator.style.display = 'block';

            const loader = new OBJLoader();
            const modelPath = '@21859_Rainbow_Trout_v1.obj'; // Make sure this path is correct!

            loader.load(
                modelPath,
                // onLoad callback
                function (object) {
                    loadedObject = object; // Store reference

                    // --- Centering and Scaling (Example) ---
                    // This often requires manual adjustment based on the specific model
                    const box = new THREE.Box3().setFromObject(object);
                    const center = box.getCenter(new THREE.Vector3());
                    const size = box.getSize(new THREE.Vector3());

                    // Scale object
                    const maxDim = Math.max(size.x, size.y, size.z);
                    const desiredSize = 30; // Adjust this target size
                    const scale = desiredSize / maxDim;
                    object.scale.set(scale, scale, scale);

                     // Recompute bounding box after scaling
                    box.setFromObject(object);
                    box.getCenter(center); // Get new center after scaling

                    // Offset object to center at origin
                    object.position.sub(center);

                    // Apply a standard material if none is loaded
                     object.traverse((child) => {
                        if (child instanceof THREE.Mesh) {
                             // Use MeshStandardMaterial for better lighting response
                            child.material = new THREE.MeshStandardMaterial({
                                color: 0xaaaaaa, // Default grey
                                metalness: 0.2,
                                roughness: 0.8,
                                // map: texture, // Add texture loading if you have a texture map
                            });
                        }
                    });


                    scene.add(object);
                    console.log('Model loaded successfully:', modelPath);
                    if (loadingIndicator) loadingIndicator.style.display = 'none';
                    animate(); // Start animation loop ONLY after model is loaded
                },
                // onProgress callback (optional)
                function (xhr) {
                    // console.log((xhr.loaded / xhr.total * 100) + '% loaded');
                },
                // onError callback
                function (error) {
                    console.error('Error loading model:', error);
                     if (loadingIndicator) {
                        loadingIndicator.textContent = 'Error loading model. Check console.';
                        loadingIndicator.style.color = 'red';
                     }
                     alert(`Failed to load model: ${modelPath}. Check console for details.`);

                }
            );
        }

        // --- Update Viewports ---
        function updateViewports() {
            if (!canvasContainer) return;

            const width = canvasContainer.clientWidth;
            const height = canvasContainer.clientHeight;

            // Calculate sizes for the 3 views (Top full width, bottom split)
            const topHeight = Math.floor((height - viewPadding * 2) * 0.5); // Adjusted height calc
            const bottomHeight = height - topHeight - viewPadding * 2;      // Remaining height
            const halfWidth = Math.floor((width - viewPadding * 2) / 2);    // Half width for bottom views

            // Update viewport information (adjust layout as needed)
            viewportInfo.top = {
                x: viewPadding,
                y: height - topHeight - viewPadding, // Position top view at the top
                width: width - (viewPadding * 2),
                height: topHeight
            };

            viewportInfo.side = { // Bottom Left
                x: viewPadding,
                y: viewPadding,
                width: halfWidth,
                height: bottomHeight
            };

            viewportInfo.front = { // Bottom Right
                x: halfWidth + viewPadding, // Simple positioning
                y: viewPadding,
                width: halfWidth,
                height: bottomHeight
            };
        }

        // --- Update View Labels ---
         function updateViewLabels() {
            if (!topViewLabel || !sideViewLabel || !frontViewLabel) return;

             topViewLabel.style.left = `${viewportInfo.top.x + 5}px`;
             topViewLabel.style.top = `${viewportInfo.top.y + 5}px`;

             sideViewLabel.style.left = `${viewportInfo.side.x + 5}px`;
             sideViewLabel.style.top = `${viewportInfo.side.y + 5}px`;

             frontViewLabel.style.left = `${viewportInfo.front.x + 5}px`;
             frontViewLabel.style.top = `${viewportInfo.front.y + 5}px`;
         }


        // --- Resize Handler ---
        function onWindowResize() {
            if (!renderer || !canvasContainer) return;

            const width = canvasContainer.clientWidth;
            const height = canvasContainer.clientHeight;

            renderer.setSize(width, height);

            updateViewports(); // Recalculate viewport sizes and positions

            // Update camera aspect ratios and projection matrices
            const aspectTop = viewportInfo.top.width / viewportInfo.top.height;
            const aspectSide = viewportInfo.side.width / viewportInfo.side.height;
            const aspectFront = viewportInfo.front.width / viewportInfo.front.height;

            if (cameraTop) {
                cameraTop.left = frustumSize * aspectTop / -2;
                cameraTop.right = frustumSize * aspectTop / 2;
                cameraTop.top = frustumSize / 2;
                cameraTop.bottom = frustumSize / -2;
                cameraTop.updateProjectionMatrix();
            }
            if (cameraSide) {
                cameraSide.left = frustumSize * aspectSide / -2;
                cameraSide.right = frustumSize * aspectSide / 2;
                cameraSide.top = frustumSize / 2;
                cameraSide.bottom = frustumSize / -2;
                cameraSide.updateProjectionMatrix();
            }
            if (cameraFront) {
                cameraFront.left = frustumSize * aspectFront / -2;
                cameraFront.right = frustumSize * aspectFront / 2;
                cameraFront.top = frustumSize / 2;
                cameraFront.bottom = frustumSize / -2;
                cameraFront.updateProjectionMatrix();
            }

            updateViewLabels(); // Reposition labels
        }


        // --- Animation Loop ---
        function animate() {
            animationFrameId = requestAnimationFrame(animate);
            render();
        }

        // --- Render Function (Handles Viewports) ---
        function render() {
            if (!renderer) return;

            renderer.setScissorTest(true);

            // Render Top View
            renderer.setViewport(viewportInfo.top.x, viewportInfo.top.y, viewportInfo.top.width, viewportInfo.top.height);
            renderer.setScissor(viewportInfo.top.x, viewportInfo.top.y, viewportInfo.top.width, viewportInfo.top.height);
            if (cameraTop) renderer.render(scene, cameraTop);

            // Render Side View
            renderer.setViewport(viewportInfo.side.x, viewportInfo.side.y, viewportInfo.side.width, viewportInfo.side.height);
            renderer.setScissor(viewportInfo.side.x, viewportInfo.side.y, viewportInfo.side.width, viewportInfo.side.height);
            if (cameraSide) renderer.render(scene, cameraSide);

            // Render Front View
            renderer.setViewport(viewportInfo.front.x, viewportInfo.front.y, viewportInfo.front.width, viewportInfo.front.height);
            renderer.setScissor(viewportInfo.front.x, viewportInfo.front.y, viewportInfo.front.width, viewportInfo.front.height);
            if (cameraFront) renderer.render(scene, cameraFront);

            renderer.setScissorTest(false);
        }

         // --- Cleanup Function ---
        function cleanup() {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            window.removeEventListener('resize', onWindowResize);
            window.removeEventListener('beforeunload', cleanup);

            // Dispose Three.js objects (add more as needed)
            if (loadedObject) scene.remove(loadedObject);
            // Dispose geometries and materials if necessary
            scene.traverse(object => {
                 if (object.geometry) object.geometry.dispose();
                 if (object.material) {
                     if (Array.isArray(object.material)) {
                         object.material.forEach(material => material.dispose());
                     } else {
                         object.material.dispose();
                     }
                 }
             });

            if (renderer) renderer.dispose();
            console.log("Cleaned up Three.js resources.");
        }

        // --- Start ---
        init();

    </script>
</body>
</html> 